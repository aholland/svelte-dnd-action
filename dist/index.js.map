{"version":3,"file":"index.js","sources":["../src/helpers/dispatcher.js","../src/constants.js","../src/helpers/intersection.js","../src/helpers/listUtil.js","../src/helpers/util.js","../src/helpers/observer.js","../src/helpers/scroller.js","../src/helpers/multiScroller.js","../src/helpers/svelteNodeClone.js","../src/featureFlags.js","../src/helpers/styler.js","../src/pointerAction.js","../src/helpers/aria.js","../src/keyboardAction.js","../src/action.js","../src/wrappers/simpleStore.js","../src/wrappers/withDragHandles.js"],"sourcesContent":["// external events\nconst FINALIZE_EVENT_NAME = \"finalize\";\nconst CONSIDER_EVENT_NAME = \"consider\";\n\n/**\n * @typedef {Object} Info\n * @property {string} trigger\n * @property {string} id\n * @property {string} source\n * @param {Node} el\n * @param {Array} items\n * @param {Info} info\n */\nexport function dispatchFinalizeEvent(el, items, info) {\n    el.dispatchEvent(\n        new CustomEvent(FINALIZE_EVENT_NAME, {\n            detail: {items, info}\n        })\n    );\n}\n\n/**\n * Dispatches a consider event\n * @param {Node} el\n * @param {Array} items\n * @param {Info} info\n */\nexport function dispatchConsiderEvent(el, items, info) {\n    el.dispatchEvent(\n        new CustomEvent(CONSIDER_EVENT_NAME, {\n            detail: {items, info}\n        })\n    );\n}\n\n// internal events\nexport const DRAGGED_ENTERED_EVENT_NAME = \"draggedEntered\";\nexport const DRAGGED_LEFT_EVENT_NAME = \"draggedLeft\";\nexport const DRAGGED_OVER_INDEX_EVENT_NAME = \"draggedOverIndex\";\nexport const DRAGGED_LEFT_DOCUMENT_EVENT_NAME = \"draggedLeftDocument\";\n\nexport const DRAGGED_LEFT_TYPES = {\n    LEFT_FOR_ANOTHER: \"leftForAnother\",\n    OUTSIDE_OF_ANY: \"outsideOfAny\"\n};\n\nexport function dispatchDraggedElementEnteredContainer(containerEl, indexObj, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_ENTERED_EVENT_NAME, {\n            detail: {indexObj, draggedEl}\n        })\n    );\n}\n\n/**\n * @param containerEl - the dropzone the element left\n * @param draggedEl - the dragged element\n * @param theOtherDz - the new dropzone the element entered\n */\nexport function dispatchDraggedElementLeftContainerForAnother(containerEl, draggedEl, theOtherDz) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {\n            detail: {draggedEl, type: DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER, theOtherDz}\n        })\n    );\n}\n\nexport function dispatchDraggedElementLeftContainerForNone(containerEl, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {\n            detail: {draggedEl, type: DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY}\n        })\n    );\n}\nexport function dispatchDraggedElementIsOverIndex(containerEl, indexObj, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_OVER_INDEX_EVENT_NAME, {\n            detail: {indexObj, draggedEl}\n        })\n    );\n}\nexport function dispatchDraggedLeftDocument(draggedEl) {\n    window.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, {\n            detail: {draggedEl}\n        })\n    );\n}\n","import {DRAGGED_ENTERED_EVENT_NAME, DRAGGED_LEFT_EVENT_NAME, DRAGGED_OVER_INDEX_EVENT_NAME} from \"./helpers/dispatcher\";\n\nexport const TRIGGERS = {\n    DRAG_STARTED: \"dragStarted\",\n    DRAGGED_ENTERED: DRAGGED_ENTERED_EVENT_NAME,\n    DRAGGED_ENTERED_ANOTHER: \"dragEnteredAnother\",\n    DRAGGED_OVER_INDEX: DRAGGED_OVER_INDEX_EVENT_NAME,\n    DRAGGED_LEFT: DRAGGED_LEFT_EVENT_NAME,\n    DRAGGED_LEFT_ALL: \"draggedLeftAll\",\n    DROPPED_INTO_ZONE: \"droppedIntoZone\",\n    DROPPED_INTO_ANOTHER: \"droppedIntoAnother\",\n    DROPPED_OUTSIDE_OF_ANY: \"droppedOutsideOfAny\",\n    DRAG_STOPPED: \"dragStopped\"\n};\n\nexport const SOURCES = {\n    POINTER: \"pointer\",\n    KEYBOARD: \"keyboard\"\n};\n\nexport const SHADOW_ITEM_MARKER_PROPERTY_NAME = \"isDndShadowItem\";\nexport const SHADOW_ELEMENT_ATTRIBUTE_NAME = \"data-is-dnd-shadow-item-internal\";\nexport const SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME = \"data-is-dnd-shadow-item-hint\";\nexport const SHADOW_PLACEHOLDER_ITEM_ID = \"id:dnd-shadow-placeholder-0000\";\nexport const DRAGGED_ELEMENT_ID = \"dnd-action-dragged-el\";\nexport const SHADOW_BACKUP_ID_KEY = \"dndShadowBackupId\";\n\nexport let ITEM_ID_KEY = \"id\";\nlet activeDndZoneCount = 0;\nexport function incrementActiveDropZoneCount() {\n    activeDndZoneCount++;\n}\nexport function decrementActiveDropZoneCount() {\n    if (activeDndZoneCount === 0) {\n        throw new Error(\"Bug! trying to decrement when there are no dropzones\");\n    }\n    activeDndZoneCount--;\n}\n\n/**\n * Allows using another key instead of \"id\" in the items data. This is global and applies to all dndzones.\n * Has to be called when there are no rendered dndzones whatsoever.\n * @param {String} newKeyName\n * @throws {Error} if it was called when there are rendered dndzones or if it is given the wrong type (not a string)\n */\nexport function overrideItemIdKeyNameBeforeInitialisingDndZones(newKeyName) {\n    if (activeDndZoneCount > 0) {\n        throw new Error(\"can only override the id key before initialising any dndzone\");\n    }\n    if (typeof newKeyName !== \"string\") {\n        throw new Error(\"item id key has to be a string\");\n    }\n    printDebug(() => [\"overriding item id key name\", newKeyName]);\n    ITEM_ID_KEY = newKeyName;\n}\n\n/**\n * Gets the true ID of an item, checking for shadow backup ID first\n * @param {Object} item - The item to get the ID from\n * @returns {*} The true ID of the item\n */\nexport function getTrueId(item) {\n    // If the item has a shadow backup ID, that's the true ID\n    if (item[SHADOW_BACKUP_ID_KEY]) {\n        return item[SHADOW_BACKUP_ID_KEY];\n    }\n    // Otherwise return the regular ID\n    return item[ITEM_ID_KEY];\n}\n\nexport const isOnServer = typeof window === \"undefined\";\n\nexport let printDebug = () => {};\n\n/**\n * Allows the user to show/hide console debug output\n * * @param {boolean} isDebug\n */\nexport function setDebugMode(isDebug) {\n    if (isDebug) {\n        printDebug = (generateMessage, logFunction = console.debug) => {\n            const message = generateMessage();\n            if (Array.isArray(message)) {\n                logFunction(...message);\n            } else {\n                logFunction(message);\n            }\n        };\n    } else {\n        printDebug = () => {};\n    }\n}\n","// This is based off https://stackoverflow.com/questions/27745438/how-to-compute-getboundingclientrect-without-considering-transforms/57876601#57876601\n// It removes the transforms that are potentially applied by the flip animations\n/**\n * Gets the bounding rect but removes transforms (ex: flip animation)\n * @param {HTMLElement} el\n * @param {boolean} [onlyVisible] - use the visible rect defaults to true\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getBoundingRectNoTransforms(el, onlyVisible = true) {\n    let ta;\n    const rect = onlyVisible ? getVisibleRectRecursive(el) : el.getBoundingClientRect();\n    const style = getComputedStyle(el);\n    const tx = style.transform;\n\n    if (tx) {\n        let sx, sy, dx, dy;\n        if (tx.startsWith(\"matrix3d(\")) {\n            ta = tx.slice(9, -1).split(/, /);\n            sx = +ta[0];\n            sy = +ta[5];\n            dx = +ta[12];\n            dy = +ta[13];\n        } else if (tx.startsWith(\"matrix(\")) {\n            ta = tx.slice(7, -1).split(/, /);\n            sx = +ta[0];\n            sy = +ta[3];\n            dx = +ta[4];\n            dy = +ta[5];\n        } else {\n            return rect;\n        }\n\n        const to = style.transformOrigin;\n        const x = rect.x - dx - (1 - sx) * parseFloat(to);\n        const y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(\" \") + 1));\n        const w = sx ? rect.width / sx : el.offsetWidth;\n        const h = sy ? rect.height / sy : el.offsetHeight;\n        return {\n            x: x,\n            y: y,\n            width: w,\n            height: h,\n            top: y,\n            right: x + w,\n            bottom: y + h,\n            left: x\n        };\n    } else {\n        return rect;\n    }\n}\n\n/**\n * Gets the absolute bounding rect (accounts for the window's scroll position and removes transforms)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getAbsoluteRectNoTransforms(el) {\n    const rect = getBoundingRectNoTransforms(el);\n    return {\n        top: rect.top + window.scrollY,\n        bottom: rect.bottom + window.scrollY,\n        left: rect.left + window.scrollX,\n        right: rect.right + window.scrollX\n    };\n}\n\n/**\n * Gets the absolute bounding rect (accounts for the window's scroll position)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getAbsoluteRect(el) {\n    const rect = el.getBoundingClientRect();\n    return {\n        top: rect.top + window.scrollY,\n        bottom: rect.bottom + window.scrollY,\n        left: rect.left + window.scrollX,\n        right: rect.right + window.scrollX\n    };\n}\n\n/**\n * finds the center :)\n * @typedef {Object} Rect\n * @property {number} top\n * @property {number} bottom\n * @property {number} left\n * @property {number} right\n * @param {Rect} rect\n * @return {{x: number, y: number}}\n */\nexport function findCenter(rect) {\n    return {\n        x: (rect.left + rect.right) / 2,\n        y: (rect.top + rect.bottom) / 2\n    };\n}\n\n/**\n * @typedef {Object} Point\n * @property {number} x\n * @property {number} y\n * @param {Point} pointA\n * @param {Point} pointB\n * @return {number}\n */\nfunction calcDistance(pointA, pointB) {\n    return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));\n}\n\n/**\n * @param {Point} point\n * @param {Rect} rect\n * @return {boolean|boolean}\n */\nexport function isPointInsideRect(point, rect) {\n    return point.y <= rect.bottom && point.y >= rect.top && point.x >= rect.left && point.x <= rect.right;\n}\n\n/**\n * find the absolute coordinates of the center of a dom element\n * @param el {HTMLElement}\n * @returns {{x: number, y: number}}\n */\nexport function findCenterOfElement(el) {\n    return findCenter(getAbsoluteRect(el));\n}\n\n/**\n * @param {HTMLElement} elA\n * @param {HTMLElement} elB\n * @return {boolean}\n */\nexport function isCenterOfAInsideB(elA, elB) {\n    const centerOfA = findCenterOfElement(elA);\n    const rectOfB = getAbsoluteRectNoTransforms(elB);\n    return isPointInsideRect(centerOfA, rectOfB);\n}\n\n/**\n * @param {HTMLElement|ChildNode} elA\n * @param {HTMLElement|ChildNode} elB\n * @return {number}\n */\nexport function calcDistanceBetweenCenters(elA, elB) {\n    const centerOfA = findCenterOfElement(elA);\n    const centerOfB = findCenterOfElement(elB);\n    return calcDistance(centerOfA, centerOfB);\n}\n\n/**\n * @param {HTMLElement} el - the element to check\n * @returns {boolean} - true if the element in its entirety is off-screen including the scrollable area (the normal dom events look at the mouse rather than the element)\n */\nexport function isElementOffDocument(el) {\n    const rect = getAbsoluteRect(el);\n    return rect.right < 0 || rect.left > document.documentElement.scrollWidth || rect.bottom < 0 || rect.top > document.documentElement.scrollHeight;\n}\n\nfunction getVisibleRectRecursive(element) {\n    let rect = element.getBoundingClientRect();\n    let visibleRect = {\n        top: rect.top,\n        bottom: rect.bottom,\n        left: rect.left,\n        right: rect.right\n    };\n\n    // Traverse up the DOM hierarchy, checking for scrollable ancestors\n    let parent = element.parentElement;\n    while (parent && parent !== document.body) {\n        let parentRect = parent.getBoundingClientRect();\n\n        // Check if the parent has a scrollable overflow\n        const overflowY = window.getComputedStyle(parent).overflowY;\n        const overflowX = window.getComputedStyle(parent).overflowX;\n        const isScrollableY = overflowY === \"scroll\" || overflowY === \"auto\";\n        const isScrollableX = overflowX === \"scroll\" || overflowX === \"auto\";\n\n        // Constrain the visible area to the parent's visible area\n        if (isScrollableY) {\n            visibleRect.top = Math.max(visibleRect.top, parentRect.top);\n            visibleRect.bottom = Math.min(visibleRect.bottom, parentRect.bottom);\n        }\n        if (isScrollableX) {\n            visibleRect.left = Math.max(visibleRect.left, parentRect.left);\n            visibleRect.right = Math.min(visibleRect.right, parentRect.right);\n        }\n\n        parent = parent.parentElement;\n    }\n\n    // Finally, constrain the visible rect to the viewport\n    visibleRect.top = Math.max(visibleRect.top, 0);\n    visibleRect.bottom = Math.min(visibleRect.bottom, window.innerHeight);\n    visibleRect.left = Math.max(visibleRect.left, 0);\n    visibleRect.right = Math.min(visibleRect.right, window.innerWidth);\n\n    // Return the visible rectangle, ensuring that all values are valid\n    return {\n        top: visibleRect.top,\n        bottom: visibleRect.bottom,\n        left: visibleRect.left,\n        right: visibleRect.right,\n        width: Math.max(0, visibleRect.right - visibleRect.left),\n        height: Math.max(0, visibleRect.bottom - visibleRect.top)\n    };\n}\n","import {isCenterOfAInsideB, calcDistanceBetweenCenters, getAbsoluteRectNoTransforms, isPointInsideRect, findCenterOfElement} from \"./intersection\";\nimport {printDebug, SHADOW_ELEMENT_ATTRIBUTE_NAME} from \"../constants\";\n\nlet dzToShadowIndexToRect;\n\n/**\n * Resets the cache that allows for smarter \"would be index\" resolution. Should be called after every drag operation\n */\nexport function resetIndexesCache() {\n    printDebug(() => \"resetting indexes cache\");\n    dzToShadowIndexToRect = new Map();\n}\nresetIndexesCache();\n\n/**\n * Caches the coordinates of the shadow element when it's in a certain index in a certain dropzone.\n * Helpful in order to determine \"would be index\" more effectively\n * @param {HTMLElement} dz\n * @return {number} - the shadow element index\n */\nfunction cacheShadowRect(dz) {\n    const shadowElIndex = Array.from(dz.children).findIndex(child => child.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME));\n    if (shadowElIndex >= 0) {\n        if (!dzToShadowIndexToRect.has(dz)) {\n            dzToShadowIndexToRect.set(dz, new Map());\n        }\n        dzToShadowIndexToRect.get(dz).set(shadowElIndex, getAbsoluteRectNoTransforms(dz.children[shadowElIndex]));\n        return shadowElIndex;\n    }\n    return undefined;\n}\n\n/**\n * @typedef {Object} Index\n * @property {number} index - the would be index\n * @property {boolean} isProximityBased - false if the element is actually over the index, true if it is not over it but this index is the closest\n */\n/**\n * Find the index for the dragged element in the list it is dragged over\n * @param {HTMLElement} floatingAboveEl\n * @param {HTMLElement} collectionBelowEl\n * @returns {Index|null} -  if the element is over the container the Index object otherwise null\n */\nexport function findWouldBeIndex(floatingAboveEl, collectionBelowEl) {\n    if (!isCenterOfAInsideB(floatingAboveEl, collectionBelowEl)) {\n        return null;\n    }\n    const children = collectionBelowEl.children;\n    // the container is empty, floating element should be the first\n    if (children.length === 0) {\n        return {index: 0, isProximityBased: true};\n    }\n    const shadowElIndex = cacheShadowRect(collectionBelowEl);\n\n    // the search could be more efficient but keeping it simple for now\n    // a possible improvement: pass in the lastIndex it was found in and check there first, then expand from there\n    for (let i = 0; i < children.length; i++) {\n        if (isCenterOfAInsideB(floatingAboveEl, children[i])) {\n            const cachedShadowRect = dzToShadowIndexToRect.has(collectionBelowEl) && dzToShadowIndexToRect.get(collectionBelowEl).get(i);\n            if (cachedShadowRect) {\n                if (!isPointInsideRect(findCenterOfElement(floatingAboveEl), cachedShadowRect)) {\n                    return {index: shadowElIndex, isProximityBased: false};\n                }\n            }\n            return {index: i, isProximityBased: false};\n        }\n    }\n    // this can happen if there is space around the children so the floating element has\n    //entered the container but not any of the children, in this case we will find the nearest child\n    let minDistanceSoFar = Number.MAX_VALUE;\n    let indexOfMin = undefined;\n    // we are checking all of them because we don't know whether we are dealing with a horizontal or vertical container and where the floating element entered from\n    for (let i = 0; i < children.length; i++) {\n        const distance = calcDistanceBetweenCenters(floatingAboveEl, children[i]);\n        if (distance < minDistanceSoFar) {\n            minDistanceSoFar = distance;\n            indexOfMin = i;\n        }\n    }\n    return {index: indexOfMin, isProximityBased: true};\n}\n","/**\n * @param {Object} object\n * @return {string}\n */\nexport function toString(object) {\n    return JSON.stringify(object, null, 2);\n}\n\n/**\n * Finds the depth of the given node in the DOM tree\n * @param {HTMLElement} node\n * @return {number} - the depth of the node\n */\nexport function getDepth(node) {\n    if (!node) {\n        throw new Error(\"cannot get depth of a falsy node\");\n    }\n    return _getDepth(node, 0);\n}\nfunction _getDepth(node, countSoFar = 0) {\n    if (!node.parentElement) {\n        return countSoFar - 1;\n    }\n    return _getDepth(node.parentElement, countSoFar + 1);\n}\n\n/**\n * A simple util to shallow compare objects quickly, it doesn't validate the arguments so pass objects in\n * @param {Object} objA\n * @param {Object} objB\n * @return {boolean} - true if objA and objB are shallow equal\n */\nexport function areObjectsShallowEqual(objA, objB) {\n    if (Object.keys(objA).length !== Object.keys(objB).length) {\n        return false;\n    }\n    for (const keyA in objA) {\n        if (!{}.hasOwnProperty.call(objB, keyA) || objB[keyA] !== objA[keyA]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Shallow compares two arrays\n * @param arrA\n * @param arrB\n * @return {boolean} - whether the arrays are shallow equal\n */\nexport function areArraysShallowEqualSameOrder(arrA, arrB) {\n    if (arrA.length !== arrB.length) {\n        return false;\n    }\n    for (let i = 0; i < arrA.length; i++) {\n        if (arrA[i] !== arrB[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n","import {findWouldBeIndex, resetIndexesCache} from \"./listUtil\";\nimport {findCenterOfElement, isElementOffDocument} from \"./intersection\";\nimport {\n    dispatchDraggedElementEnteredContainer,\n    dispatchDraggedElementLeftContainerForAnother,\n    dispatchDraggedElementLeftContainerForNone,\n    dispatchDraggedLeftDocument,\n    dispatchDraggedElementIsOverIndex\n} from \"./dispatcher\";\nimport {getDepth} from \"./util\";\nimport {printDebug} from \"../constants\";\n\nconst INTERVAL_MS = 200;\nconst TOLERANCE_PX = 10;\nlet next;\n\n/**\n * Tracks the dragged elements and performs the side effects when it is dragged over a drop zone (basically dispatching custom-events scrolling)\n * @param {Set<HTMLElement>} dropZones\n * @param {HTMLElement} draggedEl\n * @param {number} [intervalMs = INTERVAL_MS]\n * @param {MultiScroller} multiScroller\n */\nexport function observe(draggedEl, dropZones, intervalMs = INTERVAL_MS, multiScroller) {\n    // initialization\n    let lastDropZoneFound;\n    let lastIndexFound;\n    let lastIsDraggedInADropZone = false;\n    let lastCentrePositionOfDragged;\n    // We are sorting to make sure that in case of nested zones of the same type the one \"on top\" is considered first\n    const dropZonesFromDeepToShallow = Array.from(dropZones).sort((dz1, dz2) => getDepth(dz2) - getDepth(dz1));\n\n    /**\n     * The main function in this module. Tracks where everything is/ should be a take the actions\n     */\n    function andNow() {\n        const currentCenterOfDragged = findCenterOfElement(draggedEl);\n        const scrolled = multiScroller.multiScrollIfNeeded();\n        // we only want to make a new decision after the element was moved a bit to prevent flickering\n        if (\n            !scrolled &&\n            lastCentrePositionOfDragged &&\n            Math.abs(lastCentrePositionOfDragged.x - currentCenterOfDragged.x) < TOLERANCE_PX &&\n            Math.abs(lastCentrePositionOfDragged.y - currentCenterOfDragged.y) < TOLERANCE_PX\n        ) {\n            next = window.setTimeout(andNow, intervalMs);\n            return;\n        }\n        if (isElementOffDocument(draggedEl)) {\n            printDebug(() => \"off document\");\n            dispatchDraggedLeftDocument(draggedEl);\n            return;\n        }\n\n        lastCentrePositionOfDragged = currentCenterOfDragged;\n        // this is a simple algorithm, potential improvement: first look at lastDropZoneFound\n        let isDraggedInADropZone = false;\n        for (const dz of dropZonesFromDeepToShallow) {\n            if (scrolled) resetIndexesCache();\n            const indexObj = findWouldBeIndex(draggedEl, dz);\n            if (indexObj === null) {\n                // it is not inside\n                continue;\n            }\n            const {index} = indexObj;\n            isDraggedInADropZone = true;\n            // the element is over a container\n            if (dz !== lastDropZoneFound) {\n                lastDropZoneFound && dispatchDraggedElementLeftContainerForAnother(lastDropZoneFound, draggedEl, dz);\n                dispatchDraggedElementEnteredContainer(dz, indexObj, draggedEl);\n                lastDropZoneFound = dz;\n            } else if (index !== lastIndexFound) {\n                dispatchDraggedElementIsOverIndex(dz, indexObj, draggedEl);\n                lastIndexFound = index;\n            }\n            // we handle looping with the 'continue' statement above\n            break;\n        }\n        // the first time the dragged element is not in any dropzone we need to notify the last dropzone it was in\n        if (!isDraggedInADropZone && lastIsDraggedInADropZone && lastDropZoneFound) {\n            dispatchDraggedElementLeftContainerForNone(lastDropZoneFound, draggedEl);\n            lastDropZoneFound = undefined;\n            lastIndexFound = undefined;\n            lastIsDraggedInADropZone = false;\n        } else {\n            lastIsDraggedInADropZone = true;\n        }\n        next = window.setTimeout(andNow, intervalMs);\n    }\n    andNow();\n}\n\n// assumption - we can only observe one dragged element at a time, this could be changed in the future\nexport function unobserve() {\n    printDebug(() => \"unobserving\");\n    clearTimeout(next);\n    resetIndexesCache();\n}\n","import {isPointInsideRect} from \"./intersection\";\nconst SCROLL_ZONE_PX = 30;\n\n/**\n * Will make a scroller that can scroll any element given to it in any direction\n * @returns {{scrollIfNeeded: function(Point, HTMLElement): boolean, resetScrolling: function(void):void}}\n */\nexport function makeScroller() {\n    let scrollingInfo;\n    function resetScrolling() {\n        scrollingInfo = {directionObj: undefined, stepPx: 0};\n    }\n    resetScrolling();\n    // directionObj {x: 0|1|-1, y:0|1|-1} - 1 means down in y and right in x\n    function scrollContainer(containerEl) {\n        const {directionObj, stepPx} = scrollingInfo;\n        if (directionObj) {\n            containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);\n            window.requestAnimationFrame(() => scrollContainer(containerEl));\n        }\n    }\n    function calcScrollStepPx(distancePx) {\n        return SCROLL_ZONE_PX - distancePx;\n    }\n\n    /**\n     * @param {Point} pointer - the pointer will be used to decide in which direction to scroll\n     * @param {HTMLElement} elementToScroll - the scroll container\n     * If the pointer is next to the sides of the element to scroll, will trigger scrolling\n     * Can be called repeatedly with updated pointer and elementToScroll values without issues\n     * @return {boolean} - true if scrolling was needed\n     */\n    function scrollIfNeeded(pointer, elementToScroll) {\n        if (!elementToScroll) {\n            return false;\n        }\n        const distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);\n        const isAlreadyScrolling = !!scrollingInfo.directionObj;\n        if (distances === null) {\n            if (isAlreadyScrolling) resetScrolling();\n            return false;\n        }\n        let [scrollingVertically, scrollingHorizontally] = [false, false];\n        // vertical\n        if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {\n            if (distances.bottom < SCROLL_ZONE_PX) {\n                scrollingVertically = true;\n                scrollingInfo.directionObj = {x: 0, y: 1};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);\n            } else if (distances.top < SCROLL_ZONE_PX) {\n                scrollingVertically = true;\n                scrollingInfo.directionObj = {x: 0, y: -1};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.top);\n            }\n            if (!isAlreadyScrolling && scrollingVertically) {\n                scrollContainer(elementToScroll);\n                return true;\n            }\n        }\n        // horizontal\n        if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {\n            if (distances.right < SCROLL_ZONE_PX) {\n                scrollingHorizontally = true;\n                scrollingInfo.directionObj = {x: 1, y: 0};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.right);\n            } else if (distances.left < SCROLL_ZONE_PX) {\n                scrollingHorizontally = true;\n                scrollingInfo.directionObj = {x: -1, y: 0};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.left);\n            }\n            if (!isAlreadyScrolling && scrollingHorizontally) {\n                scrollContainer(elementToScroll);\n                return true;\n            }\n        }\n        resetScrolling();\n        return false;\n    }\n\n    return {\n        scrollIfNeeded,\n        resetScrolling\n    };\n}\n\n/**\n * If the point is inside the element returns its distances from the sides, otherwise returns null\n * @param {Point} point\n * @param {HTMLElement} el\n * @return {null|{top: number, left: number, bottom: number, right: number}}\n */\nfunction calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {\n    // Even if the scrolling element is small it acts as a scroller for the viewport\n    const rect =\n        el === document.scrollingElement\n            ? {\n                  top: 0,\n                  bottom: window.innerHeight,\n                  left: 0,\n                  right: window.innerWidth\n              }\n            : el.getBoundingClientRect();\n    if (!isPointInsideRect(point, rect)) {\n        return null;\n    }\n    return {\n        top: point.y - rect.top,\n        bottom: rect.bottom - point.y,\n        left: point.x - rect.left,\n        right: rect.right - point.x\n    };\n}\n","import {makeScroller} from \"./scroller\";\nimport {printDebug} from \"../constants\";\nimport {getDepth} from \"./util\";\nimport {isPointInsideRect} from \"./intersection\";\n\n/**\n @typedef {Object} MultiScroller\n @property {function():boolean} multiScrollIfNeeded - call this on every \"tick\" to scroll containers if needed, returns true if anything was scrolled\n/**\n * Creates a scroller than can scroll any of the provided containers or any of their scrollable parents (including the document's scrolling element)\n * @param {HTMLElement[]} baseElementsForScrolling\n * @param {function():Point} getPointerPosition\n * @return {MultiScroller}\n */\nexport function createMultiScroller(baseElementsForScrolling = [], getPointerPosition) {\n    printDebug(() => \"creating multi-scroller\");\n    const scrollingContainersSet = findRelevantScrollContainers(baseElementsForScrolling);\n    const scrollingContainersDeepToShallow = Array.from(scrollingContainersSet).sort((dz1, dz2) => getDepth(dz2) - getDepth(dz1));\n    const {scrollIfNeeded, resetScrolling} = makeScroller();\n\n    /**\n     * @return {boolean} - was any container scrolled\n     */\n    function tick() {\n        const mousePosition = getPointerPosition();\n        if (!mousePosition || !scrollingContainersDeepToShallow) {\n            return false;\n        }\n        const scrollContainersUnderCursor = scrollingContainersDeepToShallow.filter(\n            el => isPointInsideRect(mousePosition, el.getBoundingClientRect()) || el === document.scrollingElement\n        );\n        for (let i = 0; i < scrollContainersUnderCursor.length; i++) {\n            const scrolled = scrollIfNeeded(mousePosition, scrollContainersUnderCursor[i]);\n            if (scrolled) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return {\n        multiScrollIfNeeded: scrollingContainersSet.size > 0 ? tick : () => false,\n        destroy: () => resetScrolling()\n    };\n}\n\n// internal utils\nfunction findScrollableParents(element) {\n    if (!element) {\n        return [];\n    }\n    const scrollableContainers = [];\n    let parent = element;\n    while (parent) {\n        const {overflow} = window.getComputedStyle(parent);\n        if (overflow.split(\" \").some(o => o.includes(\"auto\") || o.includes(\"scroll\"))) {\n            scrollableContainers.push(parent);\n        }\n        parent = parent.parentElement;\n    }\n    return scrollableContainers;\n}\nfunction findRelevantScrollContainers(dropZones) {\n    const scrollingContainers = new Set();\n    for (let dz of dropZones) {\n        findScrollableParents(dz).forEach(container => scrollingContainers.add(container));\n    }\n    // The scrolling element might have overflow visible and still be scrollable\n    if (\n        document.scrollingElement.scrollHeight > document.scrollingElement.clientHeight ||\n        document.scrollingElement.scrollWidth > document.scrollingElement.clientHeight\n    ) {\n        scrollingContainers.add(document.scrollingElement);\n    }\n    return scrollingContainers;\n}\n","/**\n * Fixes svelte issue when cloning node containing (or being) <select> which will loose it's value.\n * Since svelte manages select value internally.\n * @see https://github.com/sveltejs/svelte/issues/6717\n * @see https://github.com/isaacHagoel/svelte-dnd-action/issues/306\n *\n * @param {HTMLElement} el\n * @returns\n */\nexport function svelteNodeClone(el) {\n    const cloned = el.cloneNode(true);\n\n    const values = [];\n    const elIsSelect = el.tagName === \"SELECT\";\n    const selects = elIsSelect ? [el] : [...el.querySelectorAll(\"select\")];\n    for (const select of selects) {\n        values.push(select.value);\n    }\n\n    if (selects.length > 0) {\n        const clonedSelects = elIsSelect ? [cloned] : [...cloned.querySelectorAll(\"select\")];\n        for (let i = 0; i < clonedSelects.length; i++) {\n            const select = clonedSelects[i];\n            const value = values[i];\n            const optionEl = select.querySelector(`option[value=\"${value}\"`);\n            if (optionEl) {\n                optionEl.setAttribute(\"selected\", true);\n            }\n        }\n    }\n\n    const elIsCanvas = el.tagName === \"CANVAS\";\n    const canvases = elIsCanvas ? [el] : [...el.querySelectorAll(\"canvas\")];\n    if (canvases.length > 0) {\n        const clonedCanvases = elIsCanvas ? [cloned] : [...cloned.querySelectorAll(\"canvas\")];\n        for (let i = 0; i < clonedCanvases.length; i++) {\n            const canvas = canvases[i];\n            const clonedCanvas = clonedCanvases[i];\n            clonedCanvas.width = canvas.width;\n            clonedCanvas.height = canvas.height;\n            if (canvas.width > 0 && canvas.height > 0) {\n                clonedCanvas.getContext(\"2d\").drawImage(canvas, 0, 0);\n            }\n        }\n    }\n\n    return cloned;\n}\n","/**\n * @type {{USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT: string}}\n */\nexport const FEATURE_FLAG_NAMES = Object.freeze({\n    // This flag exists as a workaround for issue 454 (basically a browser bug) - seems like these rect values take time to update when in grid layout. Setting it to true can cause strange behaviour in the REPL for non-grid zones, see issue 470\n    USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT: \"USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT\"\n});\n\nconst featureFlagsMap = {\n    [FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT]: false\n};\n\n/**\n * @param {FEATURE_FLAG_NAMES} flagName\n * @param {boolean} flagValue\n */\nexport function setFeatureFlag(flagName, flagValue) {\n    if (!FEATURE_FLAG_NAMES[flagName])\n        throw new Error(`Can't set non existing feature flag ${flagName}! Supported flags: ${Object.keys(FEATURE_FLAG_NAMES)}`);\n    featureFlagsMap[flagName] = !!flagValue;\n}\n\n/**\n *\n * @param {FEATURE_FLAG_NAMES} flagName\n * @return {boolean}\n */\nexport function getFeatureFlag(flagName) {\n    if (!FEATURE_FLAG_NAMES[flagName])\n        throw new Error(`Can't get non existing feature flag ${flagName}! Supported flags: ${Object.keys(FEATURE_FLAG_NAMES)}`);\n    return featureFlagsMap[flagName];\n}\n","import {SHADOW_ELEMENT_ATTRIBUTE_NAME, DRAGGED_ELEMENT_ID} from \"../constants\";\nimport {findCenter} from \"./intersection\";\nimport {svelteNodeClone} from \"./svelteNodeClone\";\nimport {getFeatureFlag, FEATURE_FLAG_NAMES} from \"../featureFlags\";\n\nconst TRANSITION_DURATION_SECONDS = 0.2;\n\n/**\n * private helper function - creates a transition string for a property\n * @param {string} property\n * @return {string} - the transition string\n */\nfunction trs(property) {\n    return `${property} ${TRANSITION_DURATION_SECONDS}s ease`;\n}\n/**\n * clones the given element and applies proper styles and transitions to the dragged element\n * @param {HTMLElement} originalElement\n * @param {Point} [positionCenterOnXY]\n * @return {Node} - the cloned, styled element\n */\nexport function createDraggedElementFrom(originalElement, positionCenterOnXY) {\n    const rect = originalElement.getBoundingClientRect();\n    const draggedEl = svelteNodeClone(originalElement);\n    copyStylesFromTo(originalElement, draggedEl);\n    draggedEl.id = DRAGGED_ELEMENT_ID;\n    draggedEl.style.position = \"fixed\";\n    let elTopPx = rect.top;\n    let elLeftPx = rect.left;\n    draggedEl.style.top = `${elTopPx}px`;\n    draggedEl.style.left = `${elLeftPx}px`;\n    if (positionCenterOnXY) {\n        const center = findCenter(rect);\n        elTopPx -= center.y - positionCenterOnXY.y;\n        elLeftPx -= center.x - positionCenterOnXY.x;\n        window.setTimeout(() => {\n            draggedEl.style.top = `${elTopPx}px`;\n            draggedEl.style.left = `${elLeftPx}px`;\n        }, 0);\n    }\n    draggedEl.style.margin = \"0\";\n    // we can't have relative or automatic height and width or it will break the illusion\n    draggedEl.style.boxSizing = \"border-box\";\n    draggedEl.style.height = `${rect.height}px`;\n    draggedEl.style.width = `${rect.width}px`;\n    draggedEl.style.transition = `${trs(\"top\")}, ${trs(\"left\")}, ${trs(\"background-color\")}, ${trs(\"opacity\")}, ${trs(\"color\")} `;\n    // this is a workaround for a strange browser bug that causes the right border to disappear when all the transitions are added at the same time\n    window.setTimeout(() => (draggedEl.style.transition += `, ${trs(\"width\")}, ${trs(\"height\")}`), 0);\n    draggedEl.style.zIndex = \"9999\";\n    draggedEl.style.cursor = \"grabbing\";\n\n    return draggedEl;\n}\n\n/**\n * styles the dragged element to a 'dropped' state\n * @param {HTMLElement} draggedEl\n */\nexport function moveDraggedElementToWasDroppedState(draggedEl) {\n    draggedEl.style.cursor = \"grab\";\n}\n\n/**\n * Morphs the dragged element style, maintains the mouse pointer within the element\n * @param {HTMLElement} draggedEl\n * @param {HTMLElement} copyFromEl - the element the dragged element should look like, typically the shadow element\n * @param {number} currentMouseX\n * @param {number} currentMouseY\n */\nexport function morphDraggedElementToBeLike(draggedEl, copyFromEl, currentMouseX, currentMouseY) {\n    copyStylesFromTo(copyFromEl, draggedEl);\n    const newRect = copyFromEl.getBoundingClientRect();\n    const draggedElRect = draggedEl.getBoundingClientRect();\n    const widthChange = newRect.width - draggedElRect.width;\n    const heightChange = newRect.height - draggedElRect.height;\n    if (widthChange || heightChange) {\n        const relativeDistanceOfMousePointerFromDraggedSides = {\n            left: (currentMouseX - draggedElRect.left) / draggedElRect.width,\n            top: (currentMouseY - draggedElRect.top) / draggedElRect.height\n        };\n        if (!getFeatureFlag(FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT)) {\n            draggedEl.style.height = `${newRect.height}px`;\n            draggedEl.style.width = `${newRect.width}px`;\n        }\n        draggedEl.style.left = `${parseFloat(draggedEl.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange}px`;\n        draggedEl.style.top = `${parseFloat(draggedEl.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange}px`;\n    }\n}\n\n/**\n * @param {HTMLElement} copyFromEl\n * @param {HTMLElement} copyToEl\n */\nfunction copyStylesFromTo(copyFromEl, copyToEl) {\n    const computedStyle = window.getComputedStyle(copyFromEl);\n    Array.from(computedStyle)\n        .filter(\n            s =>\n                s.startsWith(\"background\") ||\n                s.startsWith(\"padding\") ||\n                s.startsWith(\"font\") ||\n                s.startsWith(\"text\") ||\n                s.startsWith(\"align\") ||\n                s.startsWith(\"justify\") ||\n                s.startsWith(\"display\") ||\n                s.startsWith(\"flex\") ||\n                s.startsWith(\"border\") ||\n                s === \"opacity\" ||\n                s === \"color\" ||\n                s === \"list-style-type\" ||\n                // copying with and height to make up for rect update timing issues in some browsers\n                (getFeatureFlag(FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT) && (s === \"width\" || s === \"height\"))\n        )\n        .forEach(s => copyToEl.style.setProperty(s, computedStyle.getPropertyValue(s), computedStyle.getPropertyPriority(s)));\n}\n\n/**\n * makes the element compatible with being draggable\n * @param {HTMLElement} draggableEl\n * @param {boolean} dragDisabled\n */\nexport function styleDraggable(draggableEl, dragDisabled) {\n    draggableEl.draggable = false;\n    draggableEl.ondragstart = () => false;\n    if (!dragDisabled) {\n        draggableEl.style.userSelect = \"none\";\n        draggableEl.style.WebkitUserSelect = \"none\";\n        draggableEl.style.cursor = \"grab\";\n    } else {\n        draggableEl.style.userSelect = \"\";\n        draggableEl.style.WebkitUserSelect = \"\";\n        draggableEl.style.cursor = \"\";\n    }\n}\n\n/**\n * Hides the provided element so that it can stay in the dom without interrupting\n * @param {HTMLElement} dragTarget\n */\nexport function hideElement(dragTarget) {\n    dragTarget.style.display = \"none\";\n    dragTarget.style.position = \"fixed\";\n    dragTarget.style.zIndex = \"-5\";\n}\n\n/**\n * styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function decorateShadowEl(shadowEl) {\n    shadowEl.style.visibility = \"hidden\";\n    shadowEl.setAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME, \"true\");\n}\n\n/**\n * undo the styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function unDecorateShadowElement(shadowEl) {\n    shadowEl.style.visibility = \"\";\n    shadowEl.removeAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);\n}\n\n/**\n * will mark the given dropzones as visually active\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object (so the styles can be removed)\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleActiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = styles[style];\n        });\n        getClasses(dz).forEach(c => dz.classList.add(c));\n    });\n}\n\n/**\n * will remove the 'active' styling from given dropzones\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleInactiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = \"\";\n        });\n        getClasses(dz).forEach(c => dz.classList.contains(c) && dz.classList.remove(c));\n    });\n}\n\n/**\n * will prevent the provided element from shrinking by setting its minWidth and minHeight to the current width and height values\n * @param {HTMLElement} el\n * @return {function(): void} - run this function to undo the operation and restore the original values\n */\nexport function preventShrinking(el) {\n    const originalMinHeight = el.style.minHeight;\n    el.style.minHeight = window.getComputedStyle(el).getPropertyValue(\"height\");\n    const originalMinWidth = el.style.minWidth;\n    el.style.minWidth = window.getComputedStyle(el).getPropertyValue(\"width\");\n    return function undo() {\n        el.style.minHeight = originalMinHeight;\n        el.style.minWidth = originalMinWidth;\n    };\n}\n","import {\n    decrementActiveDropZoneCount,\n    incrementActiveDropZoneCount,\n    ITEM_ID_KEY,\n    printDebug,\n    SHADOW_ELEMENT_ATTRIBUTE_NAME,\n    SHADOW_ITEM_MARKER_PROPERTY_NAME,\n    SHADOW_PLACEHOLDER_ITEM_ID,\n    SHADOW_BACKUP_ID_KEY,\n    SOURCES,\n    TRIGGERS\n} from \"./constants\";\nimport {observe, unobserve} from \"./helpers/observer\";\nimport {createMultiScroller} from \"./helpers/multiScroller\";\nimport {\n    createDraggedElementFrom,\n    decorateShadowEl,\n    hideElement,\n    morphDraggedElementToBeLike,\n    moveDraggedElementToWasDroppedState,\n    preventShrinking,\n    styleActiveDropZones,\n    styleDraggable,\n    styleInactiveDropZones,\n    unDecorateShadowElement\n} from \"./helpers/styler\";\nimport {\n    dispatchConsiderEvent,\n    dispatchFinalizeEvent,\n    DRAGGED_ENTERED_EVENT_NAME,\n    DRAGGED_LEFT_DOCUMENT_EVENT_NAME,\n    DRAGGED_LEFT_EVENT_NAME,\n    DRAGGED_LEFT_TYPES,\n    DRAGGED_OVER_INDEX_EVENT_NAME\n} from \"./helpers/dispatcher\";\nimport {areArraysShallowEqualSameOrder, areObjectsShallowEqual, toString} from \"./helpers/util\";\nimport {getBoundingRectNoTransforms} from \"./helpers/intersection\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst MIN_OBSERVATION_INTERVAL_MS = 100;\nconst DISABLED_OBSERVATION_INTERVAL_MS = 20;\nconst MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;\nconst DEFAULT_TOUCH_DELAY_MS = 80;\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\nconst ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE = \"data-is-dnd-original-dragged-item\";\n\nlet originalDragTarget;\nlet draggedEl;\nlet draggedElData;\nlet draggedElType;\nlet originDropZone;\nlet originIndex;\nlet shadowElData;\nlet shadowElDropZone;\nlet dragStartMousePosition;\nlet currentMousePosition;\nlet isWorkingOnPreviousDrag = false;\nlet finalizingPreviousDrag = false;\nlet unlockOriginDzMinDimensions;\nlet isDraggedOutsideOfAnyDz = false;\nlet scheduledForRemovalAfterDrop = [];\nlet multiScroller;\nlet touchDragHoldTimer;\nlet touchHoldElapsed = false;\n\n// a map from type to a set of drop-zones\nconst typeToDropZones = new Map();\n// important - this is needed because otherwise the config that would be used for everyone is the config of the element that created the event listeners\nconst dzToConfig = new Map();\n// this is needed in order to be able to cleanup old listeners and avoid stale closures issues (as the listener is defined within each zone)\nconst elToMouseDownListener = new WeakMap();\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n}\n\n/* functions to manage observing the dragged element and trigger custom drag-events */\nfunction watchDraggedElement() {\n    printDebug(() => \"watching dragged element\");\n    const dropZones = typeToDropZones.get(draggedElType);\n\n    for (const dz of dropZones) {\n        dz.addEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.addEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.addEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n\n    // it is important that we don't have an interval that is faster than the flip duration because it can cause elements to jump bach and forth\n    const setIntervalMs = Math.max(...Array.from(dropZones.keys()).map(dz => dzToConfig.get(dz).dropAnimationDurationMs));\n    const observationIntervalMs = setIntervalMs === 0 ? DISABLED_OBSERVATION_INTERVAL_MS : Math.max(setIntervalMs, MIN_OBSERVATION_INTERVAL_MS); // if setIntervalMs is 0 it goes to 20, otherwise it is max between it and min observation.\n    multiScroller = createMultiScroller(dropZones, () => currentMousePosition);\n    observe(draggedEl, dropZones, observationIntervalMs * 1.07, multiScroller);\n}\nfunction unWatchDraggedElement() {\n    printDebug(() => \"unwatching dragged element\");\n    const dropZones = typeToDropZones.get(draggedElType);\n    for (const dz of dropZones) {\n        dz.removeEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.removeEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.removeEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n    // ensuring multiScroller is not already destroyed before destroying\n    if (multiScroller) {\n        multiScroller.destroy();\n        multiScroller = undefined;\n    }\n    unobserve();\n}\n\nfunction findShadowElementIdx(items) {\n    return items.findIndex(item => !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n}\nfunction createShadowElData(draggedElData) {\n    return {\n        ...draggedElData, \n        [SHADOW_ITEM_MARKER_PROPERTY_NAME]: true, \n        [ITEM_ID_KEY]: SHADOW_PLACEHOLDER_ITEM_ID,\n        [SHADOW_BACKUP_ID_KEY]: draggedElData[ITEM_ID_KEY]\n    };\n}\n\n/* custom drag-events handlers */\nfunction handleDraggedEntered(e) {\n    printDebug(() => [\"dragged entered\", e.currentTarget, e.detail]);\n    let {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"ignoring dragged entered because drop is currently disabled\");\n        return;\n    }\n    isDraggedOutsideOfAnyDz = false;\n    // this deals with another race condition. in rare occasions (super rapid operations) the list hasn't updated yet\n    items = items.filter(item => !item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n    printDebug(() => `dragged entered items ${toString(items)}`);\n\n    if (originDropZone !== e.currentTarget) {\n        const originZoneItems = dzToConfig.get(originDropZone).items;\n        const newOriginZoneItems = originZoneItems.filter(item => !item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n        dispatchConsiderEvent(originDropZone, newOriginZoneItems, {\n            trigger: TRIGGERS.DRAGGED_ENTERED_ANOTHER,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    }\n    const {index, isProximityBased} = e.detail.indexObj;\n    const shadowElIdx = isProximityBased && index === e.currentTarget.children.length - 1 ? index + 1 : index;\n    shadowElDropZone = e.currentTarget;\n    items.splice(shadowElIdx, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_ENTERED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\nfunction handleDraggedLeft(e) {\n    // dealing with a rare race condition on extremely rapid clicking and dropping\n    if (!isWorkingOnPreviousDrag) return;\n    printDebug(() => [\"dragged left\", e.currentTarget, e.detail]);\n    const {items: originalItems, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    const items = [...originalItems];\n    const shadowElIdx = findShadowElementIdx(items);\n    if (shadowElIdx !== -1) {\n        items.splice(shadowElIdx, 1);\n    }\n    const origShadowDz = shadowElDropZone;\n    shadowElDropZone = undefined;\n    const {type, theOtherDz} = e.detail;\n    if (\n        type === DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY ||\n        (type === DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER && theOtherDz !== originDropZone && dzToConfig.get(theOtherDz).dropFromOthersDisabled)\n    ) {\n        printDebug(() => \"dragged left all, putting shadow element back in the origin dz\");\n        isDraggedOutsideOfAnyDz = true;\n        shadowElDropZone = originDropZone;\n        // if the last zone it left is the origin dz, we will put it back into items (which we just removed it from)\n        const originZoneItems = origShadowDz === originDropZone ? items : [...dzToConfig.get(originDropZone).items];\n        originZoneItems.splice(originIndex, 0, shadowElData);\n        dispatchConsiderEvent(originDropZone, originZoneItems, {\n            trigger: TRIGGERS.DRAGGED_LEFT_ALL,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    }\n    // for the origin dz, when the dragged is outside of any, this will be fired in addition to the previous. this is for simplicity\n    dispatchConsiderEvent(e.currentTarget, items, {\n        trigger: TRIGGERS.DRAGGED_LEFT,\n        id: draggedElData[ITEM_ID_KEY],\n        source: SOURCES.POINTER\n    });\n}\nfunction handleDraggedIsOverIndex(e) {\n    printDebug(() => [\"dragged is over index\", e.currentTarget, e.detail]);\n    const {items: originalItems, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    const items = [...originalItems];\n    isDraggedOutsideOfAnyDz = false;\n    const {index} = e.detail.indexObj;\n    const shadowElIdx = findShadowElementIdx(items);\n    if (shadowElIdx !== -1) {\n        items.splice(shadowElIdx, 1);\n    }\n    items.splice(index, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_OVER_INDEX, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\n// Global mouse/touch-events handlers\nfunction handleMouseMove(e) {\n    e.preventDefault();\n    const c = e.touches ? e.touches[0] : e;\n    currentMousePosition = {x: c.clientX, y: c.clientY};\n    draggedEl.style.transform = `translate3d(${currentMousePosition.x - dragStartMousePosition.x}px, ${\n        currentMousePosition.y - dragStartMousePosition.y\n    }px, 0)`;\n}\n\nfunction handleDrop() {\n    printDebug(() => \"dropped\");\n    finalizingPreviousDrag = true;\n    // cleanup\n    window.removeEventListener(\"mousemove\", handleMouseMove);\n    window.removeEventListener(\"touchmove\", handleMouseMove);\n    window.removeEventListener(\"mouseup\", handleDrop);\n    window.removeEventListener(\"touchend\", handleDrop);\n    unWatchDraggedElement();\n    moveDraggedElementToWasDroppedState(draggedEl);\n\n    if (!shadowElDropZone) {\n        printDebug(() => \"element was dropped right after it left origin but before entering somewhere else\");\n        shadowElDropZone = originDropZone;\n    }\n    printDebug(() => [\"dropped in dz\", shadowElDropZone]);\n    let {items, type} = dzToConfig.get(shadowElDropZone);\n    styleInactiveDropZones(\n        typeToDropZones.get(type),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    let shadowElIdx = findShadowElementIdx(items);\n    // the handler might remove the shadow element, ex: dragula like copy on drag\n    if (shadowElIdx === -1) {\n        if (shadowElDropZone === originDropZone) {\n            shadowElIdx = originIndex;\n        }\n    }\n\n    items = items.map(item => {\n        if (item[SHADOW_ITEM_MARKER_PROPERTY_NAME]) {\n            // Restore the original data when finalizing\n            return draggedElData;\n        }\n        return item;\n    });\n    function finalizeWithinZone() {\n        unlockOriginDzMinDimensions();\n        dispatchFinalizeEvent(shadowElDropZone, items, {\n            trigger: isDraggedOutsideOfAnyDz ? TRIGGERS.DROPPED_OUTSIDE_OF_ANY : TRIGGERS.DROPPED_INTO_ZONE,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n        if (shadowElDropZone !== originDropZone) {\n            // letting the origin drop zone know the element was permanently taken away\n            dispatchFinalizeEvent(originDropZone, dzToConfig.get(originDropZone).items, {\n                trigger: TRIGGERS.DROPPED_INTO_ANOTHER,\n                id: draggedElData[ITEM_ID_KEY],\n                source: SOURCES.POINTER\n            });\n        }\n        // In edge cases the dom might have not been updated yet so we can't rely on data list index\n        const domShadowEl = Array.from(shadowElDropZone.children).find(c => c.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME));\n        if (domShadowEl) unDecorateShadowElement(domShadowEl);\n        cleanupPostDrop();\n    }\n    if (dzToConfig.get(shadowElDropZone).dropAnimationDisabled) {\n        finalizeWithinZone();\n    } else {\n        animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);\n    }\n}\n\n// helper function for handleDrop\nfunction animateDraggedToFinalPosition(shadowElIdx, callback) {\n    const shadowElRect =\n        shadowElIdx > -1\n            ? getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx], false)\n            : getBoundingRectNoTransforms(shadowElDropZone, false);\n    const newTransform = {\n        x: shadowElRect.left - parseFloat(draggedEl.style.left),\n        y: shadowElRect.top - parseFloat(draggedEl.style.top)\n    };\n    const {dropAnimationDurationMs} = dzToConfig.get(shadowElDropZone);\n    const transition = `transform ${dropAnimationDurationMs}ms ease`;\n    draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + \",\" + transition : transition;\n    draggedEl.style.transform = `translate3d(${newTransform.x}px, ${newTransform.y}px, 0)`;\n    window.setTimeout(callback, dropAnimationDurationMs);\n}\n\nfunction scheduleDZForRemovalAfterDrop(dz, destroy) {\n    scheduledForRemovalAfterDrop.push({dz, destroy});\n    window.requestAnimationFrame(() => {\n        hideElement(dz);\n        document.body.appendChild(dz);\n    });\n}\n/* cleanup */\nfunction cleanupPostDrop() {\n    // Remove the temporary elements that were kept in the DOM during the drag\n    if (draggedEl && draggedEl.remove) {\n        draggedEl.remove();\n    }\n    if (originalDragTarget && originalDragTarget.remove) {\n        originalDragTarget.remove();\n    }\n\n    draggedEl = undefined;\n    originalDragTarget = undefined;\n    draggedElData = undefined;\n    draggedElType = undefined;\n    originDropZone = undefined;\n    originIndex = undefined;\n    shadowElData = undefined;\n    shadowElDropZone = undefined;\n    dragStartMousePosition = undefined;\n    currentMousePosition = undefined;\n    isWorkingOnPreviousDrag = false;\n    finalizingPreviousDrag = false;\n    unlockOriginDzMinDimensions = undefined;\n    isDraggedOutsideOfAnyDz = false;\n    if (touchDragHoldTimer) {\n        clearTimeout(touchDragHoldTimer);\n    }\n    touchDragHoldTimer = undefined;\n    touchHoldElapsed = false;\n    if (scheduledForRemovalAfterDrop.length) {\n        printDebug(() => [\"will destroy zones that were removed during drag\", scheduledForRemovalAfterDrop]);\n        scheduledForRemovalAfterDrop.forEach(({dz, destroy}) => {\n            destroy();\n            dz.remove();\n        });\n        scheduledForRemovalAfterDrop = [];\n    }\n}\n\nexport function dndzone(node, options) {\n    let initialized = false;\n    const config = {\n        items: undefined,\n        type: undefined,\n        flipDurationMs: 0,\n        dragDisabled: false,\n        morphDisabled: false,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        transformDraggedElement: () => {},\n        centreDraggedOnCursor: false,\n        dropAnimationDisabled: false,\n        delayTouchStartMs: 0\n    };\n    printDebug(() => [`dndzone good to go options: ${toString(options)}, config: ${toString(config)}`, {node}]);\n    let elToIdx = new Map();\n\n    function addMaybeListeners() {\n        window.addEventListener(\"mousemove\", handleMouseMoveMaybeDragStart, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMoveMaybeDragStart, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleFalseAlarm, {passive: false});\n        window.addEventListener(\"touchend\", handleFalseAlarm, {passive: false});\n    }\n    function removeMaybeListeners() {\n        window.removeEventListener(\"mousemove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"touchmove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"mouseup\", handleFalseAlarm);\n        window.removeEventListener(\"touchend\", handleFalseAlarm);\n        if (touchDragHoldTimer) {\n            clearTimeout(touchDragHoldTimer);\n            touchDragHoldTimer = undefined;\n            touchHoldElapsed = false;\n        }\n    }\n    function handleFalseAlarm(e) {\n        removeMaybeListeners();\n        originalDragTarget = undefined;\n        dragStartMousePosition = undefined;\n        currentMousePosition = undefined;\n\n        // dragging initiated by touch events prevents onclick from initially firing\n        if (e.type === \"touchend\") {\n            const clickEvent = new Event(\"click\", {\n                bubbles: true,\n                cancelable: true\n            });\n            // doing it this way instead of calling .click() because that doesn't work for SVG elements\n            e.target.dispatchEvent(clickEvent);\n        }\n    }\n\n    function handleMouseMoveMaybeDragStart(e) {\n        const isTouch = !!e.touches;\n        const c = isTouch ? e.touches[0] : e;\n        // If touch drag delay is configured and not elapsed yet, allow scrolling until either\n        // the delay elapses (timer will call handleDragStart) or the user moves significantly,\n        // in which case we cancel the potential drag and let the interaction be a scroll.\n        if (isTouch && config.delayTouchStartMs > 0 && !touchHoldElapsed) {\n            currentMousePosition = {x: c.clientX, y: c.clientY};\n            if (\n                Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX ||\n                Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX\n            ) {\n                // User started scrolling, cancel drag attempt.\n                if (touchDragHoldTimer) {\n                    clearTimeout(touchDragHoldTimer);\n                    touchDragHoldTimer = undefined;\n                }\n                handleFalseAlarm(e);\n            }\n            return; // Do not preventDefault so scrolling works.\n        }\n\n        // legacy / post-delay path – block scrolling and maybe start drag\n        e.preventDefault();\n\n        currentMousePosition = {x: c.clientX, y: c.clientY};\n        if (\n            Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX ||\n            Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX\n        ) {\n            removeMaybeListeners();\n            handleDragStart();\n        }\n    }\n    function handleMouseDown(e) {\n        // on safari clicking on a select element doesn't fire mouseup at the end of the click and in general this makes more sense\n        if (e.target !== e.currentTarget && (e.target.value !== undefined || e.target.isContentEditable)) {\n            printDebug(() => \"won't initiate drag on a nested input element\");\n            return;\n        }\n        // prevents responding to any button but left click which equals 0 (which is falsy)\n        if (e.button) {\n            printDebug(() => `ignoring none left click button: ${e.button}`);\n            return;\n        }\n        if (isWorkingOnPreviousDrag) {\n            printDebug(() => \"cannot start a new drag before finalizing previous one\");\n            return;\n        }\n        const isTouchStart = !!e.touches;\n        const useDelay = isTouchStart && config.delayTouchStartMs > 0;\n\n        if (!useDelay) {\n            e.preventDefault();\n        }\n        e.stopPropagation();\n\n        const c = isTouchStart ? e.touches[0] : e;\n        dragStartMousePosition = {x: c.clientX, y: c.clientY};\n        currentMousePosition = {...dragStartMousePosition};\n        originalDragTarget = e.currentTarget;\n\n        if (useDelay) {\n            touchHoldElapsed = false;\n            touchDragHoldTimer = window.setTimeout(() => {\n                // If the finger is still down and no false-alarm happened\n                if (!originalDragTarget) return;\n                touchHoldElapsed = true;\n                removeMaybeListeners();\n                handleDragStart();\n            }, config.delayTouchStartMs);\n        }\n\n        addMaybeListeners();\n    }\n\n    function handleDragStart() {\n        printDebug(() => [`drag start config: ${toString(config)}`, originalDragTarget]);\n        isWorkingOnPreviousDrag = true;\n\n        // initialising globals\n        const currentIdx = elToIdx.get(originalDragTarget);\n        originIndex = currentIdx;\n        originDropZone = originalDragTarget.parentElement;\n        /** @type {ShadowRoot | HTMLDocument | Element } */\n        const rootNode = originDropZone.closest(\"dialog\") || originDropZone.closest(\"[popover]\") || originDropZone.getRootNode();\n        const originDropZoneRoot = rootNode.body || rootNode;\n        const {items: originalItems, type, centreDraggedOnCursor} = config;\n        const items = [...originalItems];\n        draggedElData = items[currentIdx];\n        draggedElType = type;\n        shadowElData = createShadowElData(draggedElData);\n\n        // creating the draggable element\n        draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);\n        originDropZoneRoot.appendChild(draggedEl);\n        // We will keep the original dom node in the dom because touch events keep firing on it, we want to re-add it after the framework removes it\n        function keepOriginalElementInDom() {\n            if (!originalDragTarget) {\n                printDebug(() => \"originalDragTarget became undefined, aborting keepOriginalElementInDom\");\n                return;\n            }\n            if (!originalDragTarget.parentElement) {\n                originalDragTarget.setAttribute(ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE, true);\n                originDropZoneRoot.appendChild(originalDragTarget);\n                // have to watch before we hide, otherwise Svelte 5 $state gets confused\n                watchDraggedElement();\n                hideElement(originalDragTarget);\n                // to prevent the outline from disappearing\n                draggedEl.focus();\n            } else {\n                window.requestAnimationFrame(keepOriginalElementInDom);\n            }\n        }\n        window.requestAnimationFrame(keepOriginalElementInDom);\n\n        styleActiveDropZones(\n            Array.from(typeToDropZones.get(config.type)).filter(dz => dz === originDropZone || !dzToConfig.get(dz).dropFromOthersDisabled),\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n\n        // removing the original element by removing its data entry\n        items.splice(currentIdx, 1, shadowElData);\n        unlockOriginDzMinDimensions = preventShrinking(originDropZone);\n\n        dispatchConsiderEvent(originDropZone, items, {trigger: TRIGGERS.DRAG_STARTED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n\n        // handing over to global handlers - starting to watch the element\n        window.addEventListener(\"mousemove\", handleMouseMove, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMove, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleDrop, {passive: false});\n        window.addEventListener(\"touchend\", handleDrop, {passive: false});\n    }\n\n    function configure({\n        items = undefined,\n        flipDurationMs: dropAnimationDurationMs = 0,\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        morphDisabled = false,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        transformDraggedElement = () => {},\n        centreDraggedOnCursor = false,\n        dropAnimationDisabled = false,\n        delayTouchStart: delayTouchStartOpt = false\n    }) {\n        config.dropAnimationDurationMs = dropAnimationDurationMs;\n\n        let effectiveDelayMs = 0;\n        if (delayTouchStartOpt === true) {\n            effectiveDelayMs = DEFAULT_TOUCH_DELAY_MS;\n        } else if (typeof delayTouchStartOpt === \"number\" && isFinite(delayTouchStartOpt) && delayTouchStartOpt >= 0) {\n            effectiveDelayMs = delayTouchStartOpt;\n        }\n        config.delayTouchStartMs = effectiveDelayMs;\n\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.morphDisabled = morphDisabled;\n        config.transformDraggedElement = transformDraggedElement;\n        config.centreDraggedOnCursor = centreDraggedOnCursor;\n        config.dropAnimationDisabled = dropAnimationDisabled;\n\n        // realtime update for dropTargetStyle\n        if (\n            initialized &&\n            isWorkingOnPreviousDrag &&\n            !finalizingPreviousDrag &&\n            (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) ||\n                !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))\n        ) {\n            styleInactiveDropZones(\n                [node],\n                () => config.dropTargetStyle,\n                () => dropTargetClasses\n            );\n            styleActiveDropZones(\n                [node],\n                () => dropTargetStyle,\n                () => dropTargetClasses\n            );\n        }\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = [...dropTargetClasses];\n\n        // realtime update for dropFromOthersDisabled\n        function getConfigProp(dz, propName) {\n            return dzToConfig.get(dz) ? dzToConfig.get(dz)[propName] : config[propName];\n        }\n        if (initialized && isWorkingOnPreviousDrag && config.dropFromOthersDisabled !== dropFromOthersDisabled) {\n            if (dropFromOthersDisabled) {\n                styleInactiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            } else {\n                styleActiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            }\n        }\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n\n        dzToConfig.set(node, config);\n        registerDropZone(node, newType);\n        const shadowElIdx = isWorkingOnPreviousDrag ? findShadowElementIdx(config.items) : -1;\n        for (let idx = 0; idx < node.children.length; idx++) {\n            const draggableEl = node.children[idx];\n            styleDraggable(draggableEl, dragDisabled);\n            if (idx === shadowElIdx) {\n                if (!morphDisabled) {\n                    morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y);\n                }\n                config.transformDraggedElement(draggedEl, draggedElData, idx);\n                decorateShadowEl(draggableEl);\n                continue;\n            }\n            draggableEl.removeEventListener(\"mousedown\", elToMouseDownListener.get(draggableEl));\n            draggableEl.removeEventListener(\"touchstart\", elToMouseDownListener.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"mousedown\", handleMouseDown);\n                draggableEl.addEventListener(\"touchstart\", handleMouseDown);\n                elToMouseDownListener.set(draggableEl, handleMouseDown);\n            }\n            // updating the idx\n            elToIdx.set(draggableEl, idx);\n\n            if (!initialized) {\n                initialized = true;\n            }\n        }\n    }\n    configure(options);\n\n    return {\n        update: newOptions => {\n            printDebug(() => `pointer dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            function destroyDz() {\n                printDebug(() => \"pointer dndzone will destroy\");\n                unregisterDropZone(node, dzToConfig.get(node).type);\n                dzToConfig.delete(node);\n            }\n            if (isWorkingOnPreviousDrag && !node.closest(`[${ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE}]`)) {\n                printDebug(() => \"pointer dndzone will be scheduled for destruction\");\n                scheduleDZForRemovalAfterDrop(node, destroyDz);\n            } else {\n                destroyDz();\n            }\n        }\n    };\n}\n","import {isOnServer} from \"../constants\";\n\nconst INSTRUCTION_IDs = {\n    DND_ZONE_ACTIVE: \"dnd-zone-active\",\n    DND_ZONE_DRAG_DISABLED: \"dnd-zone-drag-disabled\"\n};\nconst ID_TO_INSTRUCTION = {\n    [INSTRUCTION_IDs.DND_ZONE_ACTIVE]: \"Tab to one the items and press space-bar or enter to start dragging it\",\n    [INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED]: \"This is a disabled drag and drop list\"\n};\n\nconst ALERT_DIV_ID = \"dnd-action-aria-alert\";\nlet alertsDiv;\n\nfunction initAriaOnBrowser() {\n    if (alertsDiv) {\n        // it is already initialized\n        return;\n    }\n    // setting the dynamic alerts\n    alertsDiv = document.createElement(\"div\");\n    (function initAlertsDiv() {\n        alertsDiv.id = ALERT_DIV_ID;\n        // tab index -1 makes the alert be read twice on chrome for some reason\n        //alertsDiv.tabIndex = -1;\n        alertsDiv.style.position = \"fixed\";\n        alertsDiv.style.bottom = \"0\";\n        alertsDiv.style.left = \"0\";\n        alertsDiv.style.zIndex = \"-5\";\n        alertsDiv.style.opacity = \"0\";\n        alertsDiv.style.height = \"0\";\n        alertsDiv.style.width = \"0\";\n        alertsDiv.setAttribute(\"role\", \"alert\");\n    })();\n    document.body.prepend(alertsDiv);\n\n    // setting the instructions\n    Object.entries(ID_TO_INSTRUCTION).forEach(([id, txt]) => document.body.prepend(instructionToHiddenDiv(id, txt)));\n}\n\n/**\n * Initializes the static aria instructions so they can be attached to zones\n * @return {{DND_ZONE_ACTIVE: string, DND_ZONE_DRAG_DISABLED: string} | null} - the IDs for static aria instruction (to be used via aria-describedby) or null on the server\n */\nexport function initAria() {\n    if (isOnServer) return null;\n    if (document.readyState === \"complete\") {\n        initAriaOnBrowser();\n    } else {\n        window.addEventListener(\"DOMContentLoaded\", initAriaOnBrowser);\n    }\n    return {...INSTRUCTION_IDs};\n}\n\n/**\n * Removes all the artifacts (dom elements) added by this module\n */\nexport function destroyAria() {\n    if (isOnServer || !alertsDiv) return;\n    Object.keys(ID_TO_INSTRUCTION).forEach(id => document.getElementById(id)?.remove());\n    alertsDiv.remove();\n    alertsDiv = undefined;\n}\n\nfunction instructionToHiddenDiv(id, txt) {\n    const div = document.createElement(\"div\");\n    div.id = id;\n    div.innerHTML = `<p>${txt}</p>`;\n    div.style.display = \"none\";\n    div.style.position = \"fixed\";\n    div.style.zIndex = \"-5\";\n    return div;\n}\n\n/**\n * Will make the screen reader alert the provided text to the user\n * @param {string} txt\n */\nexport function alertToScreenReader(txt) {\n    if (isOnServer) return;\n    if (!alertsDiv) {\n        initAriaOnBrowser();\n    }\n    alertsDiv.innerHTML = \"\";\n    const alertText = document.createTextNode(txt);\n    alertsDiv.appendChild(alertText);\n    // this is needed for Safari\n    alertsDiv.style.display = \"none\";\n    alertsDiv.style.display = \"inline\";\n}\n","import {decrementActiveDropZoneCount, incrementActiveDropZoneCount, ITEM_ID_KEY, SOURCES, TRIGGERS} from \"./constants\";\nimport {styleActiveDropZones, styleInactiveDropZones} from \"./helpers/styler\";\nimport {dispatchConsiderEvent, dispatchFinalizeEvent} from \"./helpers/dispatcher\";\nimport {initAria, alertToScreenReader, destroyAria} from \"./helpers/aria\";\nimport {toString} from \"./helpers/util\";\nimport {printDebug} from \"./constants\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\n\nlet isDragging = false;\nlet draggedItemType;\nlet focusedDz;\nlet focusedDzLabel = \"\";\nlet focusedItem;\nlet focusedItemId;\nlet focusedItemLabel = \"\";\nconst allDragTargets = new WeakSet();\nconst elToKeyDownListeners = new WeakMap();\nconst elToFocusListeners = new WeakMap();\nconst dzToHandles = new Map();\nconst dzToConfig = new Map();\nconst typeToDropZones = new Map();\n\n/* TODO (potentially)\n * what's the deal with the black border of voice-reader not following focus?\n * maybe keep focus on the last dragged item upon drop?\n */\n\nlet INSTRUCTION_IDs;\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"adding global keydown and click handlers\");\n        INSTRUCTION_IDs = initAria();\n        window.addEventListener(\"keydown\", globalKeyDownHandler);\n        window.addEventListener(\"click\", globalClickHandler);\n    }\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    printDebug(() => \"unregistering drop-zone\");\n    if (focusedDz === dropZoneEl) {\n        handleDrop();\n    }\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"removing global keydown and click handlers\");\n        window.removeEventListener(\"keydown\", globalKeyDownHandler);\n        window.removeEventListener(\"click\", globalClickHandler);\n        INSTRUCTION_IDs = undefined;\n        destroyAria();\n    }\n}\n\nfunction globalKeyDownHandler(e) {\n    if (!isDragging) return;\n    switch (e.key) {\n        case \"Escape\": {\n            handleDrop();\n            break;\n        }\n    }\n}\n\nfunction globalClickHandler() {\n    if (!isDragging) return;\n    if (!allDragTargets.has(document.activeElement)) {\n        printDebug(() => \"clicked outside of any draggable\");\n        handleDrop();\n    }\n}\n\nfunction handleZoneFocus(e) {\n    printDebug(() => \"zone focus\");\n    if (!isDragging) return;\n    const newlyFocusedDz = e.currentTarget;\n    if (newlyFocusedDz === focusedDz) return;\n\n    focusedDzLabel = newlyFocusedDz.getAttribute(\"aria-label\") || \"\";\n    const {items: originItems} = dzToConfig.get(focusedDz);\n    const originItem = originItems.find(item => item[ITEM_ID_KEY] === focusedItemId);\n    const originIdx = originItems.indexOf(originItem);\n    const itemToMove = originItems.splice(originIdx, 1)[0];\n    const {items: targetItems, autoAriaDisabled} = dzToConfig.get(newlyFocusedDz);\n    if (\n        newlyFocusedDz.getBoundingClientRect().top < focusedDz.getBoundingClientRect().top ||\n        newlyFocusedDz.getBoundingClientRect().left < focusedDz.getBoundingClientRect().left\n    ) {\n        targetItems.push(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the end of the list ${focusedDzLabel}`);\n        }\n    } else {\n        targetItems.unshift(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the beginning of the list ${focusedDzLabel}`);\n        }\n    }\n    const dzFrom = focusedDz;\n    dispatchFinalizeEvent(dzFrom, originItems, {trigger: TRIGGERS.DROPPED_INTO_ANOTHER, id: focusedItemId, source: SOURCES.KEYBOARD});\n    dispatchFinalizeEvent(newlyFocusedDz, targetItems, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n    focusedDz = newlyFocusedDz;\n}\n\nfunction triggerAllDzsUpdate() {\n    dzToHandles.forEach(({update}, dz) => update(dzToConfig.get(dz)));\n}\n\nfunction handleDrop(dispatchConsider = true) {\n    printDebug(() => \"drop\");\n    if (!dzToConfig.get(focusedDz).autoAriaDisabled) {\n        alertToScreenReader(`Stopped dragging item ${focusedItemLabel}`);\n    }\n    if (allDragTargets.has(document.activeElement)) {\n        document.activeElement.blur();\n    }\n    if (dispatchConsider) {\n        dispatchConsiderEvent(focusedDz, dzToConfig.get(focusedDz).items, {\n            trigger: TRIGGERS.DRAG_STOPPED,\n            id: focusedItemId,\n            source: SOURCES.KEYBOARD\n        });\n    }\n    styleInactiveDropZones(\n        typeToDropZones.get(draggedItemType),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    focusedItem = null;\n    focusedItemId = null;\n    focusedItemLabel = \"\";\n    draggedItemType = null;\n    focusedDz = null;\n    focusedDzLabel = \"\";\n    isDragging = false;\n    triggerAllDzsUpdate();\n}\n//////\nexport function dndzone(node, options) {\n    const config = {\n        items: undefined,\n        type: undefined,\n        dragDisabled: false,\n        zoneTabIndex: 0,\n        zoneItemTabIndex: 0,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        autoAriaDisabled: false\n    };\n\n    function swap(arr, i, j) {\n        if (arr.length <= 1) return;\n        arr.splice(j, 1, arr.splice(i, 1, arr[j])[0]);\n    }\n\n    function handleKeyDown(e) {\n        printDebug(() => [\"handling key down\", e.key]);\n        switch (e.key) {\n            case \"Enter\":\n            case \" \": {\n                // we don't want to affect nested input elements or clickable elements\n                if ((e.target.disabled !== undefined || e.target.href || e.target.isContentEditable) && !allDragTargets.has(e.target)) {\n                    return;\n                }\n                e.preventDefault(); // preventing scrolling on spacebar\n                e.stopPropagation();\n                if (isDragging) {\n                    // TODO - should this trigger a drop? only here or in general (as in when hitting space or enter outside of any zone)?\n                    handleDrop();\n                } else {\n                    // drag start\n                    handleDragStart(e);\n                }\n                break;\n            }\n            case \"ArrowDown\":\n            case \"ArrowRight\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow down\", idx]);\n                if (idx < children.length - 1) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx + 2} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx + 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n            case \"ArrowUp\":\n            case \"ArrowLeft\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow up\", idx]);\n                if (idx > 0) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx - 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n        }\n    }\n    function handleDragStart(e) {\n        printDebug(() => \"drag start\");\n        setCurrentFocusedItem(e.currentTarget);\n        focusedDz = node;\n        draggedItemType = config.type;\n        isDragging = true;\n        const dropTargets = Array.from(typeToDropZones.get(config.type)).filter(dz => dz === focusedDz || !dzToConfig.get(dz).dropFromOthersDisabled);\n        styleActiveDropZones(\n            dropTargets,\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n        if (!config.autoAriaDisabled) {\n            let msg = `Started dragging item ${focusedItemLabel}. Use the arrow keys to move it within its list ${focusedDzLabel}`;\n            if (dropTargets.length > 1) {\n                msg += `, or tab to another list in order to move the item into it`;\n            }\n            alertToScreenReader(msg);\n        }\n        dispatchConsiderEvent(node, dzToConfig.get(node).items, {trigger: TRIGGERS.DRAG_STARTED, id: focusedItemId, source: SOURCES.KEYBOARD});\n        triggerAllDzsUpdate();\n    }\n\n    function handleClick(e) {\n        if (!isDragging) return;\n        if (e.currentTarget === focusedItem) return;\n        e.stopPropagation();\n        handleDrop(false);\n        handleDragStart(e);\n    }\n    function setCurrentFocusedItem(draggableEl) {\n        const {items} = dzToConfig.get(node);\n        const children = Array.from(node.children);\n        const focusedItemIdx = children.indexOf(draggableEl);\n        focusedItem = draggableEl;\n        focusedItem.tabIndex = config.zoneItemTabIndex;\n        focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];\n        focusedItemLabel = children[focusedItemIdx].getAttribute(\"aria-label\") || \"\";\n    }\n\n    function configure({\n        items = [],\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        zoneTabIndex = 0,\n        zoneItemTabIndex = 0,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        autoAriaDisabled = false\n    }) {\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n        config.zoneTabIndex = zoneTabIndex;\n        config.zoneItemTabIndex = zoneItemTabIndex;\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = dropTargetClasses;\n        config.autoAriaDisabled = autoAriaDisabled;\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        registerDropZone(node, newType);\n        if (!autoAriaDisabled) {\n            node.setAttribute(\"aria-disabled\", dragDisabled);\n            node.setAttribute(\"role\", \"list\");\n            node.setAttribute(\"aria-describedby\", dragDisabled ? INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED : INSTRUCTION_IDs.DND_ZONE_ACTIVE);\n        }\n        dzToConfig.set(node, config);\n\n        if (isDragging) {\n            node.tabIndex =\n                node === focusedDz ||\n                focusedItem.contains(node) ||\n                config.dropFromOthersDisabled ||\n                (focusedDz && config.type !== dzToConfig.get(focusedDz).type)\n                    ? -1\n                    : 0;\n        } else {\n            node.tabIndex = config.zoneTabIndex;\n        }\n\n        node.addEventListener(\"focus\", handleZoneFocus);\n\n        for (let i = 0; i < node.children.length; i++) {\n            const draggableEl = node.children[i];\n            allDragTargets.add(draggableEl);\n            draggableEl.tabIndex = isDragging ? -1 : config.zoneItemTabIndex;\n            if (!autoAriaDisabled) {\n                draggableEl.setAttribute(\"role\", \"listitem\");\n            }\n            draggableEl.removeEventListener(\"keydown\", elToKeyDownListeners.get(draggableEl));\n            draggableEl.removeEventListener(\"click\", elToFocusListeners.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"keydown\", handleKeyDown);\n                elToKeyDownListeners.set(draggableEl, handleKeyDown);\n                draggableEl.addEventListener(\"click\", handleClick);\n                elToFocusListeners.set(draggableEl, handleClick);\n            }\n            if (isDragging && config.items[i][ITEM_ID_KEY] === focusedItemId) {\n                printDebug(() => [\"focusing on\", {i, focusedItemId}]);\n                // if it is a nested dropzone, it was re-rendered and we need to refresh our pointer\n                focusedItem = draggableEl;\n                focusedItem.tabIndex = config.zoneItemTabIndex;\n                // without this the element loses focus if it moves backwards in the list\n                draggableEl.focus();\n            }\n        }\n    }\n    configure(options);\n\n    const handles = {\n        update: newOptions => {\n            printDebug(() => `keyboard dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            printDebug(() => \"keyboard dndzone will destroy\");\n            unregisterDropZone(node, config.type);\n            dzToConfig.delete(node);\n            dzToHandles.delete(node);\n        }\n    };\n    dzToHandles.set(node, handles);\n    return handles;\n}\n","import {dndzone as pointerDndZone} from \"./pointerAction\";\nimport {dndzone as keyboardDndZone} from \"./keyboardAction\";\nimport {ITEM_ID_KEY, SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME} from \"./constants\";\nimport {toString} from \"./helpers/util\";\n\n/**\n * A custom action to turn any container to a dnd zone and all of its direct children to draggables\n * Supports mouse, touch and keyboard interactions.\n * Dispatches two events that the container is expected to react to by modifying its list of items,\n * which will then feed back in to this action via the update function\n *\n * @typedef {object} Options\n * @property {array} items - the list of items that was used to generate the children of the given node (the list used in the #each block\n * @property {string} [type] - the type of the dnd zone. children dragged from here can only be dropped in other zones of the same type, default to a base type\n * @property {number} [flipDurationMs] - if the list animated using flip (recommended), specifies the flip duration such that everything syncs with it without conflict, defaults to zero\n * @property {boolean} [dragDisabled]\n * @property {boolean} [morphDisabled] - whether dragged element should morph to zone dimensions\n * @property {boolean} [dropFromOthersDisabled]\n * @property {number} [zoneTabIndex] - set the tabindex of the list container when not dragging\n * @property {number} [zoneItemTabIndex] - set the tabindex of the list container items when not dragging\n * @property {object} [dropTargetStyle]\n * @property {string[]} [dropTargetClasses]\n * @property {boolean|number} [delayTouchStart] - On touch devices, wait this long before converting the gesture to a drag.\n * `true` uses the built-in default (80 ms).\n * @property {boolean} [dropAnimationDisabled] - cancels the drop animation to place\n * @property {function} [transformDraggedElement]\n * @param {HTMLElement} node - the element to enhance\n * @param {Options} options\n * @return {{update: function, destroy: function}}\n */\nexport function dndzone(node, options) {\n    if (shouldIgnoreZone(node)) {\n        return {\n            update: () => {},\n            destroy: () => {}\n        };\n    }\n    validateOptions(options);\n    const pointerZone = pointerDndZone(node, options);\n    const keyboardZone = keyboardDndZone(node, options);\n    return {\n        update: newOptions => {\n            validateOptions(newOptions);\n            pointerZone.update(newOptions);\n            keyboardZone.update(newOptions);\n        },\n        destroy: () => {\n            pointerZone.destroy();\n            keyboardZone.destroy();\n        }\n    };\n}\n\n/**\n * If the user marked something in the ancestry of our node as shadow element, we can ignore it\n * We need the user to mark it for us because svelte updates the action from deep to shallow (but renders top down)\n * @param {HTMLElement} node\n * @return {boolean}\n */\nfunction shouldIgnoreZone(node) {\n    return !!node.closest(`[${SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME}=\"true\"]`);\n}\n\nfunction validateOptions(options) {\n    /*eslint-disable*/\n    const {\n        items,\n        flipDurationMs,\n        type,\n        dragDisabled,\n        morphDisabled,\n        dropFromOthersDisabled,\n        zoneTabIndex,\n        zoneItemTabIndex,\n        dropTargetStyle,\n        dropTargetClasses,\n        transformDraggedElement,\n        autoAriaDisabled,\n        centreDraggedOnCursor,\n        delayTouchStart,\n        dropAnimationDisabled,\n        ...rest\n    } = options;\n    /*eslint-enable*/\n    if (Object.keys(rest).length > 0) {\n        console.warn(`dndzone will ignore unknown options`, rest);\n    }\n    if (!items) {\n        throw new Error(\"no 'items' key provided to dndzone\");\n    }\n    const itemWithMissingId = items.find(item => !{}.hasOwnProperty.call(item, ITEM_ID_KEY));\n    if (itemWithMissingId) {\n        throw new Error(`missing '${ITEM_ID_KEY}' property for item ${toString(itemWithMissingId)}`);\n    }\n    if (dropTargetClasses && !Array.isArray(dropTargetClasses)) {\n        throw new Error(`dropTargetClasses should be an array but instead it is a ${typeof dropTargetClasses}, ${toString(dropTargetClasses)}`);\n    }\n    if (zoneTabIndex && !isInt(zoneTabIndex)) {\n        throw new Error(`zoneTabIndex should be a number but instead it is a ${typeof zoneTabIndex}, ${toString(zoneTabIndex)}`);\n    }\n    if (zoneItemTabIndex && !isInt(zoneItemTabIndex)) {\n        throw new Error(`zoneItemTabIndex should be a number but instead it is a ${typeof zoneItemTabIndex}, ${toString(zoneItemTabIndex)}`);\n    }\n    if (delayTouchStart !== undefined && delayTouchStart !== false) {\n        const validBoolean = delayTouchStart === true;\n        const validNumber = typeof delayTouchStart === \"number\" && isFinite(delayTouchStart) && delayTouchStart >= 0;\n        if (!validBoolean && !validNumber) {\n            throw new Error(\n                `delayTouchStart should be a boolean (true/false) or a non-negative number but instead it is a ${typeof delayTouchStart}, ${toString(\n                    delayTouchStart\n                )}`\n            );\n        }\n    }\n}\n\nfunction isInt(value) {\n    return (\n        !isNaN(value) &&\n        (function (x) {\n            return (x | 0) === x;\n        })(parseFloat(value))\n    );\n}\n","export function createStore(initialValue) {\n    let _val = initialValue;\n    const subs = new Set();\n    return {\n        get: () => _val,\n        set: newVal => {\n            _val = newVal;\n            Array.from(subs).forEach(cb => cb(_val));\n        },\n        subscribe: cb => {\n            subs.add(cb);\n            cb(_val);\n        },\n        unsubscribe: cb => {\n            subs.delete(cb);\n        }\n    };\n}\n","import {SOURCES, TRIGGERS} from \"../constants\";\nimport {dndzone} from \"../action\";\nimport {createStore} from \"./simpleStore\";\n\nconst isItemsDragDisabled = createStore(true);\nconst userDragDisabled = createStore(false);\n\nfunction getAddedOptions() {\n    return {\n        dragDisabled: userDragDisabled.get() || isItemsDragDisabled.get(),\n        zoneItemTabIndex: -1\n    };\n}\n\n/**\n * This is an action that wraps around the dndzone action to make it easy to work with drag handles\n * When using this you must also use the 'dragHandle' action (see below) on an element inside each item within the zone\n * Credit for the idea and initial implementation goes to @gleuch (Greg Leuch) and @geovie (Georg Vienna)\n *\n * @param {HTMLElement} node\n * @param options - will be passed down to the dndzone\n * @return {{update: (newOptions: Object) => {}, destroy: () => {}}}\n */\nexport function dragHandleZone(node, options) {\n    // Initialise stores from initial options\n    userDragDisabled.set(options?.dragDisabled ?? false);\n\n    let currentOptions = options;\n\n    const zone = dndzone(node, {\n        ...currentOptions,\n        ...getAddedOptions()\n    });\n\n    function updateZone() {\n        zone.update({\n            ...currentOptions,\n            ...getAddedOptions()\n        });\n    }\n\n    // Subscribe to internal store so finishing a drag updates the zone\n    isItemsDragDisabled.subscribe(updateZone);\n\n    // We don't need to subscribe to userDragDisabled here because updates to\n    // it always come through the `update` lifecycle and will call `updateZone`\n    // anyway.\n\n    function consider(e) {\n        const {\n            info: {source, trigger}\n        } = e.detail;\n        // Ensure dragging is stopped on drag finish via keyboard\n        if (source === SOURCES.KEYBOARD && trigger === TRIGGERS.DRAG_STOPPED) {\n            isItemsDragDisabled.set(true);\n        }\n    }\n\n    function finalize(e) {\n        const {\n            info: {source}\n        } = e.detail;\n        // Ensure dragging is stopped on drag finish via pointer (mouse, touch)\n        if (source === SOURCES.POINTER) {\n            isItemsDragDisabled.set(true);\n        }\n    }\n\n    node.addEventListener(\"consider\", consider);\n    node.addEventListener(\"finalize\", finalize);\n\n    return {\n        update: newOptions => {\n            currentOptions = newOptions;\n            // keep store in sync with external prop\n            userDragDisabled.set(currentOptions?.dragDisabled ?? false);\n            updateZone();\n        },\n        destroy: () => {\n            node.removeEventListener(\"consider\", consider);\n            node.removeEventListener(\"finalize\", finalize);\n            isItemsDragDisabled.unsubscribe(updateZone);\n        }\n    };\n}\n\n/**\n * This should be used to mark drag handles inside items that belong to a 'dragHandleZone' (see above)\n * @param {HTMLElement} handle\n * @return {{update: *, destroy: *}}\n */\nexport function dragHandle(handle) {\n    handle.setAttribute(\"role\", \"button\");\n\n    function startDrag(e) {\n        // preventing default to prevent lag on touch devices (because of the browser checking for screen scrolling)\n        e.preventDefault();\n        isItemsDragDisabled.set(false);\n\n        // Reset the startDrag/isItemsDragDisabled if the user releases the mouse/touch without initiating a drag\n        window.addEventListener(\"mouseup\", resetStartDrag);\n        window.addEventListener(\"touchend\", resetStartDrag);\n    }\n\n    function handleKeyDown(e) {\n        if (e.key === \"Enter\" || e.key === \" \") isItemsDragDisabled.set(false);\n    }\n\n    function resetStartDrag() {\n        isItemsDragDisabled.set(true);\n        window.removeEventListener(\"mouseup\", resetStartDrag);\n        window.removeEventListener(\"touchend\", resetStartDrag);\n    }\n\n    const recomputeHandleState = () => {\n        const userDisabled = userDragDisabled.get();\n        const internalDisabled = isItemsDragDisabled.get();\n\n        if (userDisabled) {\n            handle.tabIndex = -1;\n            handle.style.cursor = \"\"; // default cursor\n        } else {\n            handle.tabIndex = internalDisabled ? 0 : -1;\n            handle.style.cursor = internalDisabled ? \"grab\" : \"grabbing\";\n        }\n    };\n\n    // Subscribe to both stores\n    userDragDisabled.subscribe(recomputeHandleState);\n    isItemsDragDisabled.subscribe(recomputeHandleState);\n\n    handle.addEventListener(\"mousedown\", startDrag);\n    handle.addEventListener(\"touchstart\", startDrag);\n    handle.addEventListener(\"keydown\", handleKeyDown);\n    return {\n        update: () => {},\n        destroy: () => {\n            handle.removeEventListener(\"mousedown\", startDrag);\n            handle.removeEventListener(\"touchstart\", startDrag);\n            handle.removeEventListener(\"keydown\", handleKeyDown);\n            userDragDisabled.unsubscribe(recomputeHandleState);\n            isItemsDragDisabled.unsubscribe(recomputeHandleState);\n        }\n    };\n}\n"],"names":["FINALIZE_EVENT_NAME","CONSIDER_EVENT_NAME","dispatchFinalizeEvent","el","items","info","dispatchConsiderEvent","DRAGGED_ENTERED_EVENT_NAME","DRAGGED_LEFT_EVENT_NAME","DRAGGED_OVER_INDEX_EVENT_NAME","DRAGGED_LEFT_DOCUMENT_EVENT_NAME","DRAGGED_LEFT_TYPES","dispatchDraggedElementEnteredContainer","containerEl","indexObj","draggedEl","dispatchDraggedElementLeftContainerForAnother","theOtherDz","dispatchDraggedElementLeftContainerForNone","dispatchDraggedElementIsOverIndex","dispatchDraggedLeftDocument","TRIGGERS","SOURCES","SHADOW_ITEM_MARKER_PROPERTY_NAME","SHADOW_ELEMENT_ATTRIBUTE_NAME","SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME","SHADOW_PLACEHOLDER_ITEM_ID","DRAGGED_ELEMENT_ID","SHADOW_BACKUP_ID_KEY","ITEM_ID_KEY","activeDndZoneCount","incrementActiveDropZoneCount","decrementActiveDropZoneCount","overrideItemIdKeyNameBeforeInitialisingDndZones","newKeyName","printDebug","getTrueId","item","isOnServer","setDebugMode","isDebug","generateMessage","logFunction","message","getBoundingRectNoTransforms","onlyVisible","ta","rect","getVisibleRectRecursive","style","tx","sx","sy","dx","dy","to","x","y","w","getAbsoluteRectNoTransforms","getAbsoluteRect","findCenter","calcDistance","pointA","pointB","isPointInsideRect","point","findCenterOfElement","isCenterOfAInsideB","elA","elB","centerOfA","rectOfB","calcDistanceBetweenCenters","centerOfB","isElementOffDocument","element","visibleRect","parent","parentRect","overflowY","overflowX","isScrollableY","isScrollableX","dzToShadowIndexToRect","resetIndexesCache","cacheShadowRect","dz","shadowElIndex","child","findWouldBeIndex","floatingAboveEl","collectionBelowEl","children","i","cachedShadowRect","minDistanceSoFar","indexOfMin","distance","toString","object","getDepth","node","_getDepth","countSoFar","areObjectsShallowEqual","objA","objB","keyA","areArraysShallowEqualSameOrder","arrA","arrB","INTERVAL_MS","TOLERANCE_PX","next","observe","dropZones","intervalMs","multiScroller","lastDropZoneFound","lastIndexFound","lastIsDraggedInADropZone","lastCentrePositionOfDragged","dropZonesFromDeepToShallow","dz1","dz2","andNow","currentCenterOfDragged","scrolled","isDraggedInADropZone","index","unobserve","SCROLL_ZONE_PX","makeScroller","scrollingInfo","resetScrolling","scrollContainer","directionObj","stepPx","calcScrollStepPx","distancePx","scrollIfNeeded","pointer","elementToScroll","distances","calcInnerDistancesBetweenPointAndSidesOfElement","isAlreadyScrolling","scrollingVertically","scrollingHorizontally","createMultiScroller","baseElementsForScrolling","getPointerPosition","scrollingContainersSet","findRelevantScrollContainers","scrollingContainersDeepToShallow","tick","mousePosition","scrollContainersUnderCursor","findScrollableParents","scrollableContainers","overflow","o","scrollingContainers","container","svelteNodeClone","cloned","values","elIsSelect","selects","select","clonedSelects","value","optionEl","elIsCanvas","canvases","clonedCanvases","canvas","clonedCanvas","FEATURE_FLAG_NAMES","featureFlagsMap","setFeatureFlag","flagName","flagValue","getFeatureFlag","TRANSITION_DURATION_SECONDS","trs","property","createDraggedElementFrom","originalElement","positionCenterOnXY","copyStylesFromTo","elTopPx","elLeftPx","center","moveDraggedElementToWasDroppedState","morphDraggedElementToBeLike","copyFromEl","currentMouseX","currentMouseY","newRect","draggedElRect","widthChange","heightChange","relativeDistanceOfMousePointerFromDraggedSides","copyToEl","computedStyle","s","styleDraggable","draggableEl","dragDisabled","hideElement","dragTarget","decorateShadowEl","shadowEl","unDecorateShadowElement","styleActiveDropZones","getStyles","getClasses","styles","c","styleInactiveDropZones","preventShrinking","originalMinHeight","originalMinWidth","DEFAULT_DROP_ZONE_TYPE","MIN_OBSERVATION_INTERVAL_MS","DISABLED_OBSERVATION_INTERVAL_MS","MIN_MOVEMENT_BEFORE_DRAG_START_PX","DEFAULT_TOUCH_DELAY_MS","DEFAULT_DROP_TARGET_STYLE","ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE","originalDragTarget","draggedElData","draggedElType","originDropZone","originIndex","shadowElData","shadowElDropZone","dragStartMousePosition","currentMousePosition","isWorkingOnPreviousDrag","finalizingPreviousDrag","unlockOriginDzMinDimensions","isDraggedOutsideOfAnyDz","scheduledForRemovalAfterDrop","touchDragHoldTimer","touchHoldElapsed","typeToDropZones","dzToConfig","elToMouseDownListener","registerDropZone","dropZoneEl","type","unregisterDropZone","watchDraggedElement","handleDraggedEntered","handleDraggedLeft","handleDraggedIsOverIndex","handleDrop","setIntervalMs","observationIntervalMs","unWatchDraggedElement","findShadowElementIdx","createShadowElData","dropFromOthersDisabled","newOriginZoneItems","isProximityBased","shadowElIdx","originalItems","origShadowDz","originZoneItems","handleMouseMove","finalizeWithinZone","domShadowEl","cleanupPostDrop","animateDraggedToFinalPosition","callback","shadowElRect","newTransform","dropAnimationDurationMs","transition","scheduleDZForRemovalAfterDrop","destroy","dndzone","options","initialized","config","elToIdx","addMaybeListeners","handleMouseMoveMaybeDragStart","handleFalseAlarm","removeMaybeListeners","e","clickEvent","isTouch","handleDragStart","handleMouseDown","isTouchStart","useDelay","currentIdx","rootNode","originDropZoneRoot","centreDraggedOnCursor","keepOriginalElementInDom","configure","newType","morphDisabled","dropTargetStyle","dropTargetClasses","transformDraggedElement","dropAnimationDisabled","delayTouchStartOpt","effectiveDelayMs","getConfigProp","propName","idx","newOptions","destroyDz","INSTRUCTION_IDs","ID_TO_INSTRUCTION","ALERT_DIV_ID","alertsDiv","initAriaOnBrowser","id","txt","instructionToHiddenDiv","initAria","destroyAria","div","alertToScreenReader","alertText","isDragging","draggedItemType","focusedDz","focusedDzLabel","focusedItem","focusedItemId","focusedItemLabel","allDragTargets","elToKeyDownListeners","elToFocusListeners","dzToHandles","globalKeyDownHandler","globalClickHandler","handleZoneFocus","newlyFocusedDz","originItems","originItem","originIdx","itemToMove","targetItems","autoAriaDisabled","triggerAllDzsUpdate","update","dispatchConsider","swap","arr","j","handleKeyDown","setCurrentFocusedItem","dropTargets","msg","handleClick","focusedItemIdx","zoneTabIndex","zoneItemTabIndex","handles","shouldIgnoreZone","validateOptions","pointerZone","pointerDndZone","keyboardZone","keyboardDndZone","flipDurationMs","delayTouchStart","rest","itemWithMissingId","isInt","validBoolean","validNumber","createStore","initialValue","_val","subs","newVal","cb","isItemsDragDisabled","userDragDisabled","getAddedOptions","dragHandleZone","currentOptions","zone","updateZone","consider","source","trigger","finalize","dragHandle","handle","startDrag","resetStartDrag","recomputeHandleState","userDisabled","internalDisabled"],"mappings":"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"}