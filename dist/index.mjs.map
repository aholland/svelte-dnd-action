{"version":3,"file":"index.mjs","sources":["../src/helpers/dispatcher.js","../src/constants.js","../src/helpers/intersection.js","../src/helpers/listUtil.js","../src/helpers/util.js","../src/helpers/observer.js","../src/helpers/scroller.js","../src/helpers/multiScroller.js","../src/helpers/svelteNodeClone.js","../src/featureFlags.js","../src/helpers/styler.js","../src/pointerAction.js","../src/helpers/aria.js","../src/keyboardAction.js","../src/action.js","../src/wrappers/simpleStore.js","../src/wrappers/withDragHandles.js"],"sourcesContent":["// external events\nconst FINALIZE_EVENT_NAME = \"finalize\";\nconst CONSIDER_EVENT_NAME = \"consider\";\n\n/**\n * @typedef {Object} Info\n * @property {string} trigger\n * @property {string} id\n * @property {string} source\n * @param {Node} el\n * @param {Array} items\n * @param {Info} info\n */\nexport function dispatchFinalizeEvent(el, items, info) {\n    el.dispatchEvent(\n        new CustomEvent(FINALIZE_EVENT_NAME, {\n            detail: {items, info}\n        })\n    );\n}\n\n/**\n * Dispatches a consider event\n * @param {Node} el\n * @param {Array} items\n * @param {Info} info\n */\nexport function dispatchConsiderEvent(el, items, info) {\n    el.dispatchEvent(\n        new CustomEvent(CONSIDER_EVENT_NAME, {\n            detail: {items, info}\n        })\n    );\n}\n\n// internal events\nexport const DRAGGED_ENTERED_EVENT_NAME = \"draggedEntered\";\nexport const DRAGGED_LEFT_EVENT_NAME = \"draggedLeft\";\nexport const DRAGGED_OVER_INDEX_EVENT_NAME = \"draggedOverIndex\";\nexport const DRAGGED_LEFT_DOCUMENT_EVENT_NAME = \"draggedLeftDocument\";\n\nexport const DRAGGED_LEFT_TYPES = {\n    LEFT_FOR_ANOTHER: \"leftForAnother\",\n    OUTSIDE_OF_ANY: \"outsideOfAny\"\n};\n\nexport function dispatchDraggedElementEnteredContainer(containerEl, indexObj, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_ENTERED_EVENT_NAME, {\n            detail: {indexObj, draggedEl}\n        })\n    );\n}\n\n/**\n * @param containerEl - the dropzone the element left\n * @param draggedEl - the dragged element\n * @param theOtherDz - the new dropzone the element entered\n */\nexport function dispatchDraggedElementLeftContainerForAnother(containerEl, draggedEl, theOtherDz) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {\n            detail: {draggedEl, type: DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER, theOtherDz}\n        })\n    );\n}\n\nexport function dispatchDraggedElementLeftContainerForNone(containerEl, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {\n            detail: {draggedEl, type: DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY}\n        })\n    );\n}\nexport function dispatchDraggedElementIsOverIndex(containerEl, indexObj, draggedEl) {\n    containerEl.dispatchEvent(\n        new CustomEvent(DRAGGED_OVER_INDEX_EVENT_NAME, {\n            detail: {indexObj, draggedEl}\n        })\n    );\n}\nexport function dispatchDraggedLeftDocument(draggedEl) {\n    window.dispatchEvent(\n        new CustomEvent(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, {\n            detail: {draggedEl}\n        })\n    );\n}\n","import {DRAGGED_ENTERED_EVENT_NAME, DRAGGED_LEFT_EVENT_NAME, DRAGGED_OVER_INDEX_EVENT_NAME} from \"./helpers/dispatcher\";\n\nexport const TRIGGERS = {\n    DRAG_STARTED: \"dragStarted\",\n    DRAGGED_ENTERED: DRAGGED_ENTERED_EVENT_NAME,\n    DRAGGED_ENTERED_ANOTHER: \"dragEnteredAnother\",\n    DRAGGED_OVER_INDEX: DRAGGED_OVER_INDEX_EVENT_NAME,\n    DRAGGED_LEFT: DRAGGED_LEFT_EVENT_NAME,\n    DRAGGED_LEFT_ALL: \"draggedLeftAll\",\n    DROPPED_INTO_ZONE: \"droppedIntoZone\",\n    DROPPED_INTO_ANOTHER: \"droppedIntoAnother\",\n    DROPPED_OUTSIDE_OF_ANY: \"droppedOutsideOfAny\",\n    DRAG_STOPPED: \"dragStopped\"\n};\n\nexport const SOURCES = {\n    POINTER: \"pointer\",\n    KEYBOARD: \"keyboard\"\n};\n\nexport const SHADOW_ITEM_MARKER_PROPERTY_NAME = \"isDndShadowItem\";\nexport const SHADOW_ELEMENT_ATTRIBUTE_NAME = \"data-is-dnd-shadow-item-internal\";\nexport const SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME = \"data-is-dnd-shadow-item-hint\";\nexport const SHADOW_PLACEHOLDER_ITEM_ID = \"id:dnd-shadow-placeholder-0000\";\nexport const DRAGGED_ELEMENT_ID = \"dnd-action-dragged-el\";\nexport const SHADOW_BACKUP_ID_PROPERTY_NAME = \"dndShadowBackupId\";\n\nexport let ITEM_ID_KEY = \"id\";\nlet activeDndZoneCount = 0;\nexport function incrementActiveDropZoneCount() {\n    activeDndZoneCount++;\n}\nexport function decrementActiveDropZoneCount() {\n    if (activeDndZoneCount === 0) {\n        throw new Error(\"Bug! trying to decrement when there are no dropzones\");\n    }\n    activeDndZoneCount--;\n}\n\n/**\n * Allows using another key instead of \"id\" in the items data. This is global and applies to all dndzones.\n * Has to be called when there are no rendered dndzones whatsoever.\n * @param {String} newKeyName\n * @throws {Error} if it was called when there are rendered dndzones or if it is given the wrong type (not a string)\n */\nexport function overrideItemIdKeyNameBeforeInitialisingDndZones(newKeyName) {\n    if (activeDndZoneCount > 0) {\n        throw new Error(\"can only override the id key before initialising any dndzone\");\n    }\n    if (typeof newKeyName !== \"string\") {\n        throw new Error(\"item id key has to be a string\");\n    }\n    printDebug(() => [\"overriding item id key name\", newKeyName]);\n    ITEM_ID_KEY = newKeyName;\n}\n\n/**\n * Gets the true ID of an item, checking for shadow backup ID first\n * @param {Object} item - The item to get the ID from\n * @returns {*} The true ID of the item\n */\nexport function getTrueItemId(item) {\n    // If the item has a shadow backup ID, that's the true ID\n    if (item[SHADOW_BACKUP_ID_PROPERTY_NAME]) {\n        return item[SHADOW_BACKUP_ID_PROPERTY_NAME];\n    }\n    // Otherwise return the regular ID\n    return item[ITEM_ID_KEY];\n}\n\nexport const isOnServer = typeof window === \"undefined\";\n\nexport let printDebug = () => {};\n\n/**\n * Allows the user to show/hide console debug output\n * * @param {boolean} isDebug\n */\nexport function setDebugMode(isDebug) {\n    if (isDebug) {\n        printDebug = (generateMessage, logFunction = console.debug) => {\n            const message = generateMessage();\n            if (Array.isArray(message)) {\n                logFunction(...message);\n            } else {\n                logFunction(message);\n            }\n        };\n    } else {\n        printDebug = () => {};\n    }\n}\n","// This is based off https://stackoverflow.com/questions/27745438/how-to-compute-getboundingclientrect-without-considering-transforms/57876601#57876601\n// It removes the transforms that are potentially applied by the flip animations\n/**\n * Gets the bounding rect but removes transforms (ex: flip animation)\n * @param {HTMLElement} el\n * @param {boolean} [onlyVisible] - use the visible rect defaults to true\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getBoundingRectNoTransforms(el, onlyVisible = true) {\n    let ta;\n    const rect = onlyVisible ? getVisibleRectRecursive(el) : el.getBoundingClientRect();\n    const style = getComputedStyle(el);\n    const tx = style.transform;\n\n    if (tx) {\n        let sx, sy, dx, dy;\n        if (tx.startsWith(\"matrix3d(\")) {\n            ta = tx.slice(9, -1).split(/, /);\n            sx = +ta[0];\n            sy = +ta[5];\n            dx = +ta[12];\n            dy = +ta[13];\n        } else if (tx.startsWith(\"matrix(\")) {\n            ta = tx.slice(7, -1).split(/, /);\n            sx = +ta[0];\n            sy = +ta[3];\n            dx = +ta[4];\n            dy = +ta[5];\n        } else {\n            return rect;\n        }\n\n        const to = style.transformOrigin;\n        const x = rect.x - dx - (1 - sx) * parseFloat(to);\n        const y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(\" \") + 1));\n        const w = sx ? rect.width / sx : el.offsetWidth;\n        const h = sy ? rect.height / sy : el.offsetHeight;\n        return {\n            x: x,\n            y: y,\n            width: w,\n            height: h,\n            top: y,\n            right: x + w,\n            bottom: y + h,\n            left: x\n        };\n    } else {\n        return rect;\n    }\n}\n\n/**\n * Gets the absolute bounding rect (accounts for the window's scroll position and removes transforms)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getAbsoluteRectNoTransforms(el) {\n    const rect = getBoundingRectNoTransforms(el);\n    return {\n        top: rect.top + window.scrollY,\n        bottom: rect.bottom + window.scrollY,\n        left: rect.left + window.scrollX,\n        right: rect.right + window.scrollX\n    };\n}\n\n/**\n * Gets the absolute bounding rect (accounts for the window's scroll position)\n * @param {HTMLElement} el\n * @return {{top: number, left: number, bottom: number, right: number}}\n */\nexport function getAbsoluteRect(el) {\n    const rect = el.getBoundingClientRect();\n    return {\n        top: rect.top + window.scrollY,\n        bottom: rect.bottom + window.scrollY,\n        left: rect.left + window.scrollX,\n        right: rect.right + window.scrollX\n    };\n}\n\n/**\n * finds the center :)\n * @typedef {Object} Rect\n * @property {number} top\n * @property {number} bottom\n * @property {number} left\n * @property {number} right\n * @param {Rect} rect\n * @return {{x: number, y: number}}\n */\nexport function findCenter(rect) {\n    return {\n        x: (rect.left + rect.right) / 2,\n        y: (rect.top + rect.bottom) / 2\n    };\n}\n\n/**\n * @typedef {Object} Point\n * @property {number} x\n * @property {number} y\n * @param {Point} pointA\n * @param {Point} pointB\n * @return {number}\n */\nfunction calcDistance(pointA, pointB) {\n    return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));\n}\n\n/**\n * @param {Point} point\n * @param {Rect} rect\n * @return {boolean|boolean}\n */\nexport function isPointInsideRect(point, rect) {\n    return point.y <= rect.bottom && point.y >= rect.top && point.x >= rect.left && point.x <= rect.right;\n}\n\n/**\n * find the absolute coordinates of the center of a dom element\n * @param el {HTMLElement}\n * @returns {{x: number, y: number}}\n */\nexport function findCenterOfElement(el) {\n    return findCenter(getAbsoluteRect(el));\n}\n\n/**\n * @param {HTMLElement} elA\n * @param {HTMLElement} elB\n * @return {boolean}\n */\nexport function isCenterOfAInsideB(elA, elB) {\n    const centerOfA = findCenterOfElement(elA);\n    const rectOfB = getAbsoluteRectNoTransforms(elB);\n    return isPointInsideRect(centerOfA, rectOfB);\n}\n\n/**\n * @param {HTMLElement|ChildNode} elA\n * @param {HTMLElement|ChildNode} elB\n * @return {number}\n */\nexport function calcDistanceBetweenCenters(elA, elB) {\n    const centerOfA = findCenterOfElement(elA);\n    const centerOfB = findCenterOfElement(elB);\n    return calcDistance(centerOfA, centerOfB);\n}\n\n/**\n * @param {HTMLElement} el - the element to check\n * @returns {boolean} - true if the element in its entirety is off-screen including the scrollable area (the normal dom events look at the mouse rather than the element)\n */\nexport function isElementOffDocument(el) {\n    const rect = getAbsoluteRect(el);\n    return rect.right < 0 || rect.left > document.documentElement.scrollWidth || rect.bottom < 0 || rect.top > document.documentElement.scrollHeight;\n}\n\nfunction getVisibleRectRecursive(element) {\n    let rect = element.getBoundingClientRect();\n    let visibleRect = {\n        top: rect.top,\n        bottom: rect.bottom,\n        left: rect.left,\n        right: rect.right\n    };\n\n    // Traverse up the DOM hierarchy, checking for scrollable ancestors\n    let parent = element.parentElement;\n    while (parent && parent !== document.body) {\n        let parentRect = parent.getBoundingClientRect();\n\n        // Check if the parent has a scrollable overflow\n        const overflowY = window.getComputedStyle(parent).overflowY;\n        const overflowX = window.getComputedStyle(parent).overflowX;\n        const isScrollableY = overflowY === \"scroll\" || overflowY === \"auto\";\n        const isScrollableX = overflowX === \"scroll\" || overflowX === \"auto\";\n\n        // Constrain the visible area to the parent's visible area\n        if (isScrollableY) {\n            visibleRect.top = Math.max(visibleRect.top, parentRect.top);\n            visibleRect.bottom = Math.min(visibleRect.bottom, parentRect.bottom);\n        }\n        if (isScrollableX) {\n            visibleRect.left = Math.max(visibleRect.left, parentRect.left);\n            visibleRect.right = Math.min(visibleRect.right, parentRect.right);\n        }\n\n        parent = parent.parentElement;\n    }\n\n    // Finally, constrain the visible rect to the viewport\n    visibleRect.top = Math.max(visibleRect.top, 0);\n    visibleRect.bottom = Math.min(visibleRect.bottom, window.innerHeight);\n    visibleRect.left = Math.max(visibleRect.left, 0);\n    visibleRect.right = Math.min(visibleRect.right, window.innerWidth);\n\n    // Return the visible rectangle, ensuring that all values are valid\n    return {\n        top: visibleRect.top,\n        bottom: visibleRect.bottom,\n        left: visibleRect.left,\n        right: visibleRect.right,\n        width: Math.max(0, visibleRect.right - visibleRect.left),\n        height: Math.max(0, visibleRect.bottom - visibleRect.top)\n    };\n}\n","import {isCenterOfAInsideB, calcDistanceBetweenCenters, getAbsoluteRectNoTransforms, isPointInsideRect, findCenterOfElement} from \"./intersection\";\nimport {printDebug, SHADOW_ELEMENT_ATTRIBUTE_NAME} from \"../constants\";\n\nlet dzToShadowIndexToRect;\n\n/**\n * Resets the cache that allows for smarter \"would be index\" resolution. Should be called after every drag operation\n */\nexport function resetIndexesCache() {\n    printDebug(() => \"resetting indexes cache\");\n    dzToShadowIndexToRect = new Map();\n}\nresetIndexesCache();\n\n/**\n * Caches the coordinates of the shadow element when it's in a certain index in a certain dropzone.\n * Helpful in order to determine \"would be index\" more effectively\n * @param {HTMLElement} dz\n * @return {number} - the shadow element index\n */\nfunction cacheShadowRect(dz) {\n    const shadowElIndex = Array.from(dz.children).findIndex(child => child.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME));\n    if (shadowElIndex >= 0) {\n        if (!dzToShadowIndexToRect.has(dz)) {\n            dzToShadowIndexToRect.set(dz, new Map());\n        }\n        dzToShadowIndexToRect.get(dz).set(shadowElIndex, getAbsoluteRectNoTransforms(dz.children[shadowElIndex]));\n        return shadowElIndex;\n    }\n    return undefined;\n}\n\n/**\n * @typedef {Object} Index\n * @property {number} index - the would be index\n * @property {boolean} isProximityBased - false if the element is actually over the index, true if it is not over it but this index is the closest\n */\n/**\n * Find the index for the dragged element in the list it is dragged over\n * @param {HTMLElement} floatingAboveEl\n * @param {HTMLElement} collectionBelowEl\n * @returns {Index|null} -  if the element is over the container the Index object otherwise null\n */\nexport function findWouldBeIndex(floatingAboveEl, collectionBelowEl) {\n    if (!isCenterOfAInsideB(floatingAboveEl, collectionBelowEl)) {\n        return null;\n    }\n    const children = collectionBelowEl.children;\n    // the container is empty, floating element should be the first\n    if (children.length === 0) {\n        return {index: 0, isProximityBased: true};\n    }\n    const shadowElIndex = cacheShadowRect(collectionBelowEl);\n\n    // the search could be more efficient but keeping it simple for now\n    // a possible improvement: pass in the lastIndex it was found in and check there first, then expand from there\n    for (let i = 0; i < children.length; i++) {\n        if (isCenterOfAInsideB(floatingAboveEl, children[i])) {\n            const cachedShadowRect = dzToShadowIndexToRect.has(collectionBelowEl) && dzToShadowIndexToRect.get(collectionBelowEl).get(i);\n            if (cachedShadowRect) {\n                if (!isPointInsideRect(findCenterOfElement(floatingAboveEl), cachedShadowRect)) {\n                    return {index: shadowElIndex, isProximityBased: false};\n                }\n            }\n            return {index: i, isProximityBased: false};\n        }\n    }\n    // this can happen if there is space around the children so the floating element has\n    //entered the container but not any of the children, in this case we will find the nearest child\n    let minDistanceSoFar = Number.MAX_VALUE;\n    let indexOfMin = undefined;\n    // we are checking all of them because we don't know whether we are dealing with a horizontal or vertical container and where the floating element entered from\n    for (let i = 0; i < children.length; i++) {\n        const distance = calcDistanceBetweenCenters(floatingAboveEl, children[i]);\n        if (distance < minDistanceSoFar) {\n            minDistanceSoFar = distance;\n            indexOfMin = i;\n        }\n    }\n    return {index: indexOfMin, isProximityBased: true};\n}\n","/**\n * @param {Object} object\n * @return {string}\n */\nexport function toString(object) {\n    return JSON.stringify(object, null, 2);\n}\n\n/**\n * Finds the depth of the given node in the DOM tree\n * @param {HTMLElement} node\n * @return {number} - the depth of the node\n */\nexport function getDepth(node) {\n    if (!node) {\n        throw new Error(\"cannot get depth of a falsy node\");\n    }\n    return _getDepth(node, 0);\n}\nfunction _getDepth(node, countSoFar = 0) {\n    if (!node.parentElement) {\n        return countSoFar - 1;\n    }\n    return _getDepth(node.parentElement, countSoFar + 1);\n}\n\n/**\n * A simple util to shallow compare objects quickly, it doesn't validate the arguments so pass objects in\n * @param {Object} objA\n * @param {Object} objB\n * @return {boolean} - true if objA and objB are shallow equal\n */\nexport function areObjectsShallowEqual(objA, objB) {\n    if (Object.keys(objA).length !== Object.keys(objB).length) {\n        return false;\n    }\n    for (const keyA in objA) {\n        if (!{}.hasOwnProperty.call(objB, keyA) || objB[keyA] !== objA[keyA]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Shallow compares two arrays\n * @param arrA\n * @param arrB\n * @return {boolean} - whether the arrays are shallow equal\n */\nexport function areArraysShallowEqualSameOrder(arrA, arrB) {\n    if (arrA.length !== arrB.length) {\n        return false;\n    }\n    for (let i = 0; i < arrA.length; i++) {\n        if (arrA[i] !== arrB[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n","import {findWouldBeIndex, resetIndexesCache} from \"./listUtil\";\nimport {findCenterOfElement, isElementOffDocument} from \"./intersection\";\nimport {\n    dispatchDraggedElementEnteredContainer,\n    dispatchDraggedElementLeftContainerForAnother,\n    dispatchDraggedElementLeftContainerForNone,\n    dispatchDraggedLeftDocument,\n    dispatchDraggedElementIsOverIndex\n} from \"./dispatcher\";\nimport {getDepth} from \"./util\";\nimport {printDebug} from \"../constants\";\n\nconst INTERVAL_MS = 200;\nconst TOLERANCE_PX = 10;\nlet next;\n\n/**\n * Tracks the dragged elements and performs the side effects when it is dragged over a drop zone (basically dispatching custom-events scrolling)\n * @param {Set<HTMLElement>} dropZones\n * @param {HTMLElement} draggedEl\n * @param {number} [intervalMs = INTERVAL_MS]\n * @param {MultiScroller} multiScroller\n */\nexport function observe(draggedEl, dropZones, intervalMs = INTERVAL_MS, multiScroller) {\n    // initialization\n    let lastDropZoneFound;\n    let lastIndexFound;\n    let lastIsDraggedInADropZone = false;\n    let lastCentrePositionOfDragged;\n    // We are sorting to make sure that in case of nested zones of the same type the one \"on top\" is considered first\n    const dropZonesFromDeepToShallow = Array.from(dropZones).sort((dz1, dz2) => getDepth(dz2) - getDepth(dz1));\n\n    /**\n     * The main function in this module. Tracks where everything is/ should be a take the actions\n     */\n    function andNow() {\n        const currentCenterOfDragged = findCenterOfElement(draggedEl);\n        const scrolled = multiScroller.multiScrollIfNeeded();\n        // we only want to make a new decision after the element was moved a bit to prevent flickering\n        if (\n            !scrolled &&\n            lastCentrePositionOfDragged &&\n            Math.abs(lastCentrePositionOfDragged.x - currentCenterOfDragged.x) < TOLERANCE_PX &&\n            Math.abs(lastCentrePositionOfDragged.y - currentCenterOfDragged.y) < TOLERANCE_PX\n        ) {\n            next = window.setTimeout(andNow, intervalMs);\n            return;\n        }\n        if (isElementOffDocument(draggedEl)) {\n            printDebug(() => \"off document\");\n            dispatchDraggedLeftDocument(draggedEl);\n            return;\n        }\n\n        lastCentrePositionOfDragged = currentCenterOfDragged;\n        // this is a simple algorithm, potential improvement: first look at lastDropZoneFound\n        let isDraggedInADropZone = false;\n        for (const dz of dropZonesFromDeepToShallow) {\n            if (scrolled) resetIndexesCache();\n            const indexObj = findWouldBeIndex(draggedEl, dz);\n            if (indexObj === null) {\n                // it is not inside\n                continue;\n            }\n            const {index} = indexObj;\n            isDraggedInADropZone = true;\n            // the element is over a container\n            if (dz !== lastDropZoneFound) {\n                lastDropZoneFound && dispatchDraggedElementLeftContainerForAnother(lastDropZoneFound, draggedEl, dz);\n                dispatchDraggedElementEnteredContainer(dz, indexObj, draggedEl);\n                lastDropZoneFound = dz;\n            } else if (index !== lastIndexFound) {\n                dispatchDraggedElementIsOverIndex(dz, indexObj, draggedEl);\n                lastIndexFound = index;\n            }\n            // we handle looping with the 'continue' statement above\n            break;\n        }\n        // the first time the dragged element is not in any dropzone we need to notify the last dropzone it was in\n        if (!isDraggedInADropZone && lastIsDraggedInADropZone && lastDropZoneFound) {\n            dispatchDraggedElementLeftContainerForNone(lastDropZoneFound, draggedEl);\n            lastDropZoneFound = undefined;\n            lastIndexFound = undefined;\n            lastIsDraggedInADropZone = false;\n        } else {\n            lastIsDraggedInADropZone = true;\n        }\n        next = window.setTimeout(andNow, intervalMs);\n    }\n    andNow();\n}\n\n// assumption - we can only observe one dragged element at a time, this could be changed in the future\nexport function unobserve() {\n    printDebug(() => \"unobserving\");\n    clearTimeout(next);\n    resetIndexesCache();\n}\n","import {isPointInsideRect} from \"./intersection\";\nconst SCROLL_ZONE_PX = 30;\n\n/**\n * Will make a scroller that can scroll any element given to it in any direction\n * @returns {{scrollIfNeeded: function(Point, HTMLElement): boolean, resetScrolling: function(void):void}}\n */\nexport function makeScroller() {\n    let scrollingInfo;\n    function resetScrolling() {\n        scrollingInfo = {directionObj: undefined, stepPx: 0};\n    }\n    resetScrolling();\n    // directionObj {x: 0|1|-1, y:0|1|-1} - 1 means down in y and right in x\n    function scrollContainer(containerEl) {\n        const {directionObj, stepPx} = scrollingInfo;\n        if (directionObj) {\n            containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);\n            window.requestAnimationFrame(() => scrollContainer(containerEl));\n        }\n    }\n    function calcScrollStepPx(distancePx) {\n        return SCROLL_ZONE_PX - distancePx;\n    }\n\n    /**\n     * @param {Point} pointer - the pointer will be used to decide in which direction to scroll\n     * @param {HTMLElement} elementToScroll - the scroll container\n     * If the pointer is next to the sides of the element to scroll, will trigger scrolling\n     * Can be called repeatedly with updated pointer and elementToScroll values without issues\n     * @return {boolean} - true if scrolling was needed\n     */\n    function scrollIfNeeded(pointer, elementToScroll) {\n        if (!elementToScroll) {\n            return false;\n        }\n        const distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);\n        const isAlreadyScrolling = !!scrollingInfo.directionObj;\n        if (distances === null) {\n            if (isAlreadyScrolling) resetScrolling();\n            return false;\n        }\n        let [scrollingVertically, scrollingHorizontally] = [false, false];\n        // vertical\n        if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {\n            if (distances.bottom < SCROLL_ZONE_PX) {\n                scrollingVertically = true;\n                scrollingInfo.directionObj = {x: 0, y: 1};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);\n            } else if (distances.top < SCROLL_ZONE_PX) {\n                scrollingVertically = true;\n                scrollingInfo.directionObj = {x: 0, y: -1};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.top);\n            }\n            if (!isAlreadyScrolling && scrollingVertically) {\n                scrollContainer(elementToScroll);\n                return true;\n            }\n        }\n        // horizontal\n        if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {\n            if (distances.right < SCROLL_ZONE_PX) {\n                scrollingHorizontally = true;\n                scrollingInfo.directionObj = {x: 1, y: 0};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.right);\n            } else if (distances.left < SCROLL_ZONE_PX) {\n                scrollingHorizontally = true;\n                scrollingInfo.directionObj = {x: -1, y: 0};\n                scrollingInfo.stepPx = calcScrollStepPx(distances.left);\n            }\n            if (!isAlreadyScrolling && scrollingHorizontally) {\n                scrollContainer(elementToScroll);\n                return true;\n            }\n        }\n        resetScrolling();\n        return false;\n    }\n\n    return {\n        scrollIfNeeded,\n        resetScrolling\n    };\n}\n\n/**\n * If the point is inside the element returns its distances from the sides, otherwise returns null\n * @param {Point} point\n * @param {HTMLElement} el\n * @return {null|{top: number, left: number, bottom: number, right: number}}\n */\nfunction calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {\n    // Even if the scrolling element is small it acts as a scroller for the viewport\n    const rect =\n        el === document.scrollingElement\n            ? {\n                  top: 0,\n                  bottom: window.innerHeight,\n                  left: 0,\n                  right: window.innerWidth\n              }\n            : el.getBoundingClientRect();\n    if (!isPointInsideRect(point, rect)) {\n        return null;\n    }\n    return {\n        top: point.y - rect.top,\n        bottom: rect.bottom - point.y,\n        left: point.x - rect.left,\n        right: rect.right - point.x\n    };\n}\n","import {makeScroller} from \"./scroller\";\nimport {printDebug} from \"../constants\";\nimport {getDepth} from \"./util\";\nimport {isPointInsideRect} from \"./intersection\";\n\n/**\n @typedef {Object} MultiScroller\n @property {function():boolean} multiScrollIfNeeded - call this on every \"tick\" to scroll containers if needed, returns true if anything was scrolled\n/**\n * Creates a scroller than can scroll any of the provided containers or any of their scrollable parents (including the document's scrolling element)\n * @param {HTMLElement[]} baseElementsForScrolling\n * @param {function():Point} getPointerPosition\n * @return {MultiScroller}\n */\nexport function createMultiScroller(baseElementsForScrolling = [], getPointerPosition) {\n    printDebug(() => \"creating multi-scroller\");\n    const scrollingContainersSet = findRelevantScrollContainers(baseElementsForScrolling);\n    const scrollingContainersDeepToShallow = Array.from(scrollingContainersSet).sort((dz1, dz2) => getDepth(dz2) - getDepth(dz1));\n    const {scrollIfNeeded, resetScrolling} = makeScroller();\n\n    /**\n     * @return {boolean} - was any container scrolled\n     */\n    function tick() {\n        const mousePosition = getPointerPosition();\n        if (!mousePosition || !scrollingContainersDeepToShallow) {\n            return false;\n        }\n        const scrollContainersUnderCursor = scrollingContainersDeepToShallow.filter(\n            el => isPointInsideRect(mousePosition, el.getBoundingClientRect()) || el === document.scrollingElement\n        );\n        for (let i = 0; i < scrollContainersUnderCursor.length; i++) {\n            const scrolled = scrollIfNeeded(mousePosition, scrollContainersUnderCursor[i]);\n            if (scrolled) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return {\n        multiScrollIfNeeded: scrollingContainersSet.size > 0 ? tick : () => false,\n        destroy: () => resetScrolling()\n    };\n}\n\n// internal utils\nfunction findScrollableParents(element) {\n    if (!element) {\n        return [];\n    }\n    const scrollableContainers = [];\n    let parent = element;\n    while (parent) {\n        const {overflow} = window.getComputedStyle(parent);\n        if (overflow.split(\" \").some(o => o.includes(\"auto\") || o.includes(\"scroll\"))) {\n            scrollableContainers.push(parent);\n        }\n        parent = parent.parentElement;\n    }\n    return scrollableContainers;\n}\nfunction findRelevantScrollContainers(dropZones) {\n    const scrollingContainers = new Set();\n    for (let dz of dropZones) {\n        findScrollableParents(dz).forEach(container => scrollingContainers.add(container));\n    }\n    // The scrolling element might have overflow visible and still be scrollable\n    if (\n        document.scrollingElement.scrollHeight > document.scrollingElement.clientHeight ||\n        document.scrollingElement.scrollWidth > document.scrollingElement.clientHeight\n    ) {\n        scrollingContainers.add(document.scrollingElement);\n    }\n    return scrollingContainers;\n}\n","/**\n * Fixes svelte issue when cloning node containing (or being) <select> which will loose it's value.\n * Since svelte manages select value internally.\n * @see https://github.com/sveltejs/svelte/issues/6717\n * @see https://github.com/isaacHagoel/svelte-dnd-action/issues/306\n *\n * @param {HTMLElement} el\n * @returns\n */\nexport function svelteNodeClone(el) {\n    const cloned = el.cloneNode(true);\n\n    const values = [];\n    const elIsSelect = el.tagName === \"SELECT\";\n    const selects = elIsSelect ? [el] : [...el.querySelectorAll(\"select\")];\n    for (const select of selects) {\n        values.push(select.value);\n    }\n\n    if (selects.length > 0) {\n        const clonedSelects = elIsSelect ? [cloned] : [...cloned.querySelectorAll(\"select\")];\n        for (let i = 0; i < clonedSelects.length; i++) {\n            const select = clonedSelects[i];\n            const value = values[i];\n            const optionEl = select.querySelector(`option[value=\"${value}\"`);\n            if (optionEl) {\n                optionEl.setAttribute(\"selected\", true);\n            }\n        }\n    }\n\n    const elIsCanvas = el.tagName === \"CANVAS\";\n    const canvases = elIsCanvas ? [el] : [...el.querySelectorAll(\"canvas\")];\n    if (canvases.length > 0) {\n        const clonedCanvases = elIsCanvas ? [cloned] : [...cloned.querySelectorAll(\"canvas\")];\n        for (let i = 0; i < clonedCanvases.length; i++) {\n            const canvas = canvases[i];\n            const clonedCanvas = clonedCanvases[i];\n            clonedCanvas.width = canvas.width;\n            clonedCanvas.height = canvas.height;\n            if (canvas.width > 0 && canvas.height > 0) {\n                clonedCanvas.getContext(\"2d\").drawImage(canvas, 0, 0);\n            }\n        }\n    }\n\n    return cloned;\n}\n","/**\n * @type {{USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT: string}}\n */\nexport const FEATURE_FLAG_NAMES = Object.freeze({\n    // This flag exists as a workaround for issue 454 (basically a browser bug) - seems like these rect values take time to update when in grid layout. Setting it to true can cause strange behaviour in the REPL for non-grid zones, see issue 470\n    USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT: \"USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT\"\n});\n\nconst featureFlagsMap = {\n    [FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT]: false\n};\n\n/**\n * @param {FEATURE_FLAG_NAMES} flagName\n * @param {boolean} flagValue\n */\nexport function setFeatureFlag(flagName, flagValue) {\n    if (!FEATURE_FLAG_NAMES[flagName])\n        throw new Error(`Can't set non existing feature flag ${flagName}! Supported flags: ${Object.keys(FEATURE_FLAG_NAMES)}`);\n    featureFlagsMap[flagName] = !!flagValue;\n}\n\n/**\n *\n * @param {FEATURE_FLAG_NAMES} flagName\n * @return {boolean}\n */\nexport function getFeatureFlag(flagName) {\n    if (!FEATURE_FLAG_NAMES[flagName])\n        throw new Error(`Can't get non existing feature flag ${flagName}! Supported flags: ${Object.keys(FEATURE_FLAG_NAMES)}`);\n    return featureFlagsMap[flagName];\n}\n","import {SHADOW_ELEMENT_ATTRIBUTE_NAME, DRAGGED_ELEMENT_ID} from \"../constants\";\nimport {findCenter} from \"./intersection\";\nimport {svelteNodeClone} from \"./svelteNodeClone\";\nimport {getFeatureFlag, FEATURE_FLAG_NAMES} from \"../featureFlags\";\n\nconst TRANSITION_DURATION_SECONDS = 0.2;\n\n/**\n * private helper function - creates a transition string for a property\n * @param {string} property\n * @return {string} - the transition string\n */\nfunction trs(property) {\n    return `${property} ${TRANSITION_DURATION_SECONDS}s ease`;\n}\n/**\n * clones the given element and applies proper styles and transitions to the dragged element\n * @param {HTMLElement} originalElement\n * @param {Point} [positionCenterOnXY]\n * @return {Node} - the cloned, styled element\n */\nexport function createDraggedElementFrom(originalElement, positionCenterOnXY) {\n    const rect = originalElement.getBoundingClientRect();\n    const draggedEl = svelteNodeClone(originalElement);\n    copyStylesFromTo(originalElement, draggedEl);\n    draggedEl.id = DRAGGED_ELEMENT_ID;\n    draggedEl.style.position = \"fixed\";\n    let elTopPx = rect.top;\n    let elLeftPx = rect.left;\n    draggedEl.style.top = `${elTopPx}px`;\n    draggedEl.style.left = `${elLeftPx}px`;\n    if (positionCenterOnXY) {\n        const center = findCenter(rect);\n        elTopPx -= center.y - positionCenterOnXY.y;\n        elLeftPx -= center.x - positionCenterOnXY.x;\n        window.setTimeout(() => {\n            draggedEl.style.top = `${elTopPx}px`;\n            draggedEl.style.left = `${elLeftPx}px`;\n        }, 0);\n    }\n    draggedEl.style.margin = \"0\";\n    // we can't have relative or automatic height and width or it will break the illusion\n    draggedEl.style.boxSizing = \"border-box\";\n    draggedEl.style.height = `${rect.height}px`;\n    draggedEl.style.width = `${rect.width}px`;\n    draggedEl.style.transition = `${trs(\"top\")}, ${trs(\"left\")}, ${trs(\"background-color\")}, ${trs(\"opacity\")}, ${trs(\"color\")} `;\n    // this is a workaround for a strange browser bug that causes the right border to disappear when all the transitions are added at the same time\n    window.setTimeout(() => (draggedEl.style.transition += `, ${trs(\"width\")}, ${trs(\"height\")}`), 0);\n    draggedEl.style.zIndex = \"9999\";\n    draggedEl.style.cursor = \"grabbing\";\n\n    return draggedEl;\n}\n\n/**\n * styles the dragged element to a 'dropped' state\n * @param {HTMLElement} draggedEl\n */\nexport function moveDraggedElementToWasDroppedState(draggedEl) {\n    draggedEl.style.cursor = \"grab\";\n}\n\n/**\n * Morphs the dragged element style, maintains the mouse pointer within the element\n * @param {HTMLElement} draggedEl\n * @param {HTMLElement} copyFromEl - the element the dragged element should look like, typically the shadow element\n * @param {number} currentMouseX\n * @param {number} currentMouseY\n */\nexport function morphDraggedElementToBeLike(draggedEl, copyFromEl, currentMouseX, currentMouseY) {\n    copyStylesFromTo(copyFromEl, draggedEl);\n    const newRect = copyFromEl.getBoundingClientRect();\n    const draggedElRect = draggedEl.getBoundingClientRect();\n    const widthChange = newRect.width - draggedElRect.width;\n    const heightChange = newRect.height - draggedElRect.height;\n    if (widthChange || heightChange) {\n        const relativeDistanceOfMousePointerFromDraggedSides = {\n            left: (currentMouseX - draggedElRect.left) / draggedElRect.width,\n            top: (currentMouseY - draggedElRect.top) / draggedElRect.height\n        };\n        if (!getFeatureFlag(FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT)) {\n            draggedEl.style.height = `${newRect.height}px`;\n            draggedEl.style.width = `${newRect.width}px`;\n        }\n        draggedEl.style.left = `${parseFloat(draggedEl.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange}px`;\n        draggedEl.style.top = `${parseFloat(draggedEl.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange}px`;\n    }\n}\n\n/**\n * @param {HTMLElement} copyFromEl\n * @param {HTMLElement} copyToEl\n */\nfunction copyStylesFromTo(copyFromEl, copyToEl) {\n    const computedStyle = window.getComputedStyle(copyFromEl);\n    Array.from(computedStyle)\n        .filter(\n            s =>\n                s.startsWith(\"background\") ||\n                s.startsWith(\"padding\") ||\n                s.startsWith(\"font\") ||\n                s.startsWith(\"text\") ||\n                s.startsWith(\"align\") ||\n                s.startsWith(\"justify\") ||\n                s.startsWith(\"display\") ||\n                s.startsWith(\"flex\") ||\n                s.startsWith(\"border\") ||\n                s === \"opacity\" ||\n                s === \"color\" ||\n                s === \"list-style-type\" ||\n                // copying with and height to make up for rect update timing issues in some browsers\n                (getFeatureFlag(FEATURE_FLAG_NAMES.USE_COMPUTED_STYLE_INSTEAD_OF_BOUNDING_RECT) && (s === \"width\" || s === \"height\"))\n        )\n        .forEach(s => copyToEl.style.setProperty(s, computedStyle.getPropertyValue(s), computedStyle.getPropertyPriority(s)));\n}\n\n/**\n * makes the element compatible with being draggable\n * @param {HTMLElement} draggableEl\n * @param {boolean} dragDisabled\n */\nexport function styleDraggable(draggableEl, dragDisabled) {\n    draggableEl.draggable = false;\n    draggableEl.ondragstart = () => false;\n    if (!dragDisabled) {\n        draggableEl.style.userSelect = \"none\";\n        draggableEl.style.WebkitUserSelect = \"none\";\n        draggableEl.style.cursor = \"grab\";\n    } else {\n        draggableEl.style.userSelect = \"\";\n        draggableEl.style.WebkitUserSelect = \"\";\n        draggableEl.style.cursor = \"\";\n    }\n}\n\n/**\n * Hides the provided element so that it can stay in the dom without interrupting\n * @param {HTMLElement} dragTarget\n */\nexport function hideElement(dragTarget) {\n    dragTarget.style.display = \"none\";\n    dragTarget.style.position = \"fixed\";\n    dragTarget.style.zIndex = \"-5\";\n}\n\n/**\n * styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function decorateShadowEl(shadowEl) {\n    shadowEl.style.visibility = \"hidden\";\n    shadowEl.setAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME, \"true\");\n}\n\n/**\n * undo the styles the shadow element\n * @param {HTMLElement} shadowEl\n */\nexport function unDecorateShadowElement(shadowEl) {\n    shadowEl.style.visibility = \"\";\n    shadowEl.removeAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);\n}\n\n/**\n * will mark the given dropzones as visually active\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object (so the styles can be removed)\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleActiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = styles[style];\n        });\n        getClasses(dz).forEach(c => dz.classList.add(c));\n    });\n}\n\n/**\n * will remove the 'active' styling from given dropzones\n * @param {Array<HTMLElement>} dropZones\n * @param {Function} getStyles - maps a dropzone to a styles object\n * @param {Function} getClasses - maps a dropzone to a classList\n */\nexport function styleInactiveDropZones(dropZones, getStyles = () => {}, getClasses = () => []) {\n    dropZones.forEach(dz => {\n        const styles = getStyles(dz);\n        Object.keys(styles).forEach(style => {\n            dz.style[style] = \"\";\n        });\n        getClasses(dz).forEach(c => dz.classList.contains(c) && dz.classList.remove(c));\n    });\n}\n\n/**\n * will prevent the provided element from shrinking by setting its minWidth and minHeight to the current width and height values\n * @param {HTMLElement} el\n * @return {function(): void} - run this function to undo the operation and restore the original values\n */\nexport function preventShrinking(el) {\n    const originalMinHeight = el.style.minHeight;\n    el.style.minHeight = window.getComputedStyle(el).getPropertyValue(\"height\");\n    const originalMinWidth = el.style.minWidth;\n    el.style.minWidth = window.getComputedStyle(el).getPropertyValue(\"width\");\n    return function undo() {\n        el.style.minHeight = originalMinHeight;\n        el.style.minWidth = originalMinWidth;\n    };\n}\n","import {\n    decrementActiveDropZoneCount,\n    incrementActiveDropZoneCount,\n    ITEM_ID_KEY,\n    printDebug,\n    SHADOW_ELEMENT_ATTRIBUTE_NAME,\n    SHADOW_ITEM_MARKER_PROPERTY_NAME,\n    SHADOW_PLACEHOLDER_ITEM_ID,\n    SHADOW_BACKUP_ID_PROPERTY_NAME,\n    SOURCES,\n    TRIGGERS\n} from \"./constants\";\nimport {observe, unobserve} from \"./helpers/observer\";\nimport {createMultiScroller} from \"./helpers/multiScroller\";\nimport {\n    createDraggedElementFrom,\n    decorateShadowEl,\n    hideElement,\n    morphDraggedElementToBeLike,\n    moveDraggedElementToWasDroppedState,\n    preventShrinking,\n    styleActiveDropZones,\n    styleDraggable,\n    styleInactiveDropZones,\n    unDecorateShadowElement\n} from \"./helpers/styler\";\nimport {\n    dispatchConsiderEvent,\n    dispatchFinalizeEvent,\n    DRAGGED_ENTERED_EVENT_NAME,\n    DRAGGED_LEFT_DOCUMENT_EVENT_NAME,\n    DRAGGED_LEFT_EVENT_NAME,\n    DRAGGED_LEFT_TYPES,\n    DRAGGED_OVER_INDEX_EVENT_NAME\n} from \"./helpers/dispatcher\";\nimport {areArraysShallowEqualSameOrder, areObjectsShallowEqual, toString} from \"./helpers/util\";\nimport {getBoundingRectNoTransforms} from \"./helpers/intersection\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst MIN_OBSERVATION_INTERVAL_MS = 100;\nconst DISABLED_OBSERVATION_INTERVAL_MS = 20;\nconst MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;\nconst DEFAULT_TOUCH_DELAY_MS = 80;\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\nconst ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE = \"data-is-dnd-original-dragged-item\";\n\nlet originalDragTarget;\nlet draggedEl;\nlet draggedElData;\nlet draggedElType;\nlet originDropZone;\nlet originIndex;\nlet shadowElData;\nlet shadowElDropZone;\nlet dragStartMousePosition;\nlet currentMousePosition;\nlet isWorkingOnPreviousDrag = false;\nlet finalizingPreviousDrag = false;\nlet unlockOriginDzMinDimensions;\nlet isDraggedOutsideOfAnyDz = false;\nlet scheduledForRemovalAfterDrop = [];\nlet multiScroller;\nlet touchDragHoldTimer;\nlet touchHoldElapsed = false;\n\n// a map from type to a set of drop-zones\nconst typeToDropZones = new Map();\n// important - this is needed because otherwise the config that would be used for everyone is the config of the element that created the event listeners\nconst dzToConfig = new Map();\n// this is needed in order to be able to cleanup old listeners and avoid stale closures issues (as the listener is defined within each zone)\nconst elToMouseDownListener = new WeakMap();\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n}\n\n/* functions to manage observing the dragged element and trigger custom drag-events */\nfunction watchDraggedElement() {\n    printDebug(() => \"watching dragged element\");\n    const dropZones = typeToDropZones.get(draggedElType);\n\n    for (const dz of dropZones) {\n        dz.addEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.addEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.addEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n\n    // it is important that we don't have an interval that is faster than the flip duration because it can cause elements to jump bach and forth\n    const setIntervalMs = Math.max(...Array.from(dropZones.keys()).map(dz => dzToConfig.get(dz).dropAnimationDurationMs));\n    const observationIntervalMs = setIntervalMs === 0 ? DISABLED_OBSERVATION_INTERVAL_MS : Math.max(setIntervalMs, MIN_OBSERVATION_INTERVAL_MS); // if setIntervalMs is 0 it goes to 20, otherwise it is max between it and min observation.\n    multiScroller = createMultiScroller(dropZones, () => currentMousePosition);\n    observe(draggedEl, dropZones, observationIntervalMs * 1.07, multiScroller);\n}\nfunction unWatchDraggedElement() {\n    printDebug(() => \"unwatching dragged element\");\n    const dropZones = typeToDropZones.get(draggedElType);\n    for (const dz of dropZones) {\n        dz.removeEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);\n        dz.removeEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);\n        dz.removeEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);\n    }\n    window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);\n    // ensuring multiScroller is not already destroyed before destroying\n    if (multiScroller) {\n        multiScroller.destroy();\n        multiScroller = undefined;\n    }\n    unobserve();\n}\n\nfunction findShadowElementIdx(items) {\n    return items.findIndex(item => !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n}\nfunction createShadowElData(draggedElData) {\n    return {\n        ...draggedElData, \n        [SHADOW_ITEM_MARKER_PROPERTY_NAME]: true, \n        [ITEM_ID_KEY]: SHADOW_PLACEHOLDER_ITEM_ID,\n        [SHADOW_BACKUP_ID_PROPERTY_NAME]: draggedElData[ITEM_ID_KEY]\n    };\n}\n\n/* custom drag-events handlers */\nfunction handleDraggedEntered(e) {\n    printDebug(() => [\"dragged entered\", e.currentTarget, e.detail]);\n    let {items, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"ignoring dragged entered because drop is currently disabled\");\n        return;\n    }\n    isDraggedOutsideOfAnyDz = false;\n    // this deals with another race condition. in rare occasions (super rapid operations) the list hasn't updated yet\n    items = items.filter(item => !item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n    printDebug(() => `dragged entered items ${toString(items)}`);\n\n    if (originDropZone !== e.currentTarget) {\n        const originZoneItems = dzToConfig.get(originDropZone).items;\n        const newOriginZoneItems = originZoneItems.filter(item => !item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n        dispatchConsiderEvent(originDropZone, newOriginZoneItems, {\n            trigger: TRIGGERS.DRAGGED_ENTERED_ANOTHER,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    }\n    const {index, isProximityBased} = e.detail.indexObj;\n    const shadowElIdx = isProximityBased && index === e.currentTarget.children.length - 1 ? index + 1 : index;\n    shadowElDropZone = e.currentTarget;\n    items.splice(shadowElIdx, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_ENTERED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\nfunction handleDraggedLeft(e) {\n    // dealing with a rare race condition on extremely rapid clicking and dropping\n    if (!isWorkingOnPreviousDrag) return;\n    printDebug(() => [\"dragged left\", e.currentTarget, e.detail]);\n    const {items: originalItems, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    const items = [...originalItems];\n    const shadowElIdx = findShadowElementIdx(items);\n    if (shadowElIdx !== -1) {\n        items.splice(shadowElIdx, 1);\n    }\n    const origShadowDz = shadowElDropZone;\n    shadowElDropZone = undefined;\n    const {type, theOtherDz} = e.detail;\n    if (\n        type === DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY ||\n        (type === DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER && theOtherDz !== originDropZone && dzToConfig.get(theOtherDz).dropFromOthersDisabled)\n    ) {\n        printDebug(() => \"dragged left all, putting shadow element back in the origin dz\");\n        isDraggedOutsideOfAnyDz = true;\n        shadowElDropZone = originDropZone;\n        // if the last zone it left is the origin dz, we will put it back into items (which we just removed it from)\n        const originZoneItems = origShadowDz === originDropZone ? items : [...dzToConfig.get(originDropZone).items];\n        originZoneItems.splice(originIndex, 0, shadowElData);\n        dispatchConsiderEvent(originDropZone, originZoneItems, {\n            trigger: TRIGGERS.DRAGGED_LEFT_ALL,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n    }\n    // for the origin dz, when the dragged is outside of any, this will be fired in addition to the previous. this is for simplicity\n    dispatchConsiderEvent(e.currentTarget, items, {\n        trigger: TRIGGERS.DRAGGED_LEFT,\n        id: draggedElData[ITEM_ID_KEY],\n        source: SOURCES.POINTER\n    });\n}\nfunction handleDraggedIsOverIndex(e) {\n    printDebug(() => [\"dragged is over index\", e.currentTarget, e.detail]);\n    const {items: originalItems, dropFromOthersDisabled} = dzToConfig.get(e.currentTarget);\n    if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {\n        printDebug(() => \"drop is currently disabled\");\n        return;\n    }\n    const items = [...originalItems];\n    isDraggedOutsideOfAnyDz = false;\n    const {index} = e.detail.indexObj;\n    const shadowElIdx = findShadowElementIdx(items);\n    if (shadowElIdx !== -1) {\n        items.splice(shadowElIdx, 1);\n    }\n    items.splice(index, 0, shadowElData);\n    dispatchConsiderEvent(e.currentTarget, items, {trigger: TRIGGERS.DRAGGED_OVER_INDEX, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n}\n\n// Global mouse/touch-events handlers\nfunction handleMouseMove(e) {\n    e.preventDefault();\n    const c = e.touches ? e.touches[0] : e;\n    currentMousePosition = {x: c.clientX, y: c.clientY};\n    draggedEl.style.transform = `translate3d(${currentMousePosition.x - dragStartMousePosition.x}px, ${\n        currentMousePosition.y - dragStartMousePosition.y\n    }px, 0)`;\n}\n\nfunction handleDrop() {\n    printDebug(() => \"dropped\");\n    finalizingPreviousDrag = true;\n    // cleanup\n    window.removeEventListener(\"mousemove\", handleMouseMove);\n    window.removeEventListener(\"touchmove\", handleMouseMove);\n    window.removeEventListener(\"mouseup\", handleDrop);\n    window.removeEventListener(\"touchend\", handleDrop);\n    unWatchDraggedElement();\n    moveDraggedElementToWasDroppedState(draggedEl);\n\n    if (!shadowElDropZone) {\n        printDebug(() => \"element was dropped right after it left origin but before entering somewhere else\");\n        shadowElDropZone = originDropZone;\n    }\n    printDebug(() => [\"dropped in dz\", shadowElDropZone]);\n    let {items, type} = dzToConfig.get(shadowElDropZone);\n    styleInactiveDropZones(\n        typeToDropZones.get(type),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    let shadowElIdx = findShadowElementIdx(items);\n    // the handler might remove the shadow element, ex: dragula like copy on drag\n    if (shadowElIdx === -1) {\n        if (shadowElDropZone === originDropZone) {\n            shadowElIdx = originIndex;\n        }\n    }\n\n    items = items.map(item => {\n        if (item[SHADOW_ITEM_MARKER_PROPERTY_NAME]) {\n            // Restore the original data when finalizing\n            return draggedElData;\n        }\n        return item;\n    });\n    function finalizeWithinZone() {\n        unlockOriginDzMinDimensions();\n        dispatchFinalizeEvent(shadowElDropZone, items, {\n            trigger: isDraggedOutsideOfAnyDz ? TRIGGERS.DROPPED_OUTSIDE_OF_ANY : TRIGGERS.DROPPED_INTO_ZONE,\n            id: draggedElData[ITEM_ID_KEY],\n            source: SOURCES.POINTER\n        });\n        if (shadowElDropZone !== originDropZone) {\n            // letting the origin drop zone know the element was permanently taken away\n            dispatchFinalizeEvent(originDropZone, dzToConfig.get(originDropZone).items, {\n                trigger: TRIGGERS.DROPPED_INTO_ANOTHER,\n                id: draggedElData[ITEM_ID_KEY],\n                source: SOURCES.POINTER\n            });\n        }\n        // In edge cases the dom might have not been updated yet so we can't rely on data list index\n        const domShadowEl = Array.from(shadowElDropZone.children).find(c => c.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME));\n        if (domShadowEl) unDecorateShadowElement(domShadowEl);\n        cleanupPostDrop();\n    }\n    if (dzToConfig.get(shadowElDropZone).dropAnimationDisabled) {\n        finalizeWithinZone();\n    } else {\n        animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);\n    }\n}\n\n// helper function for handleDrop\nfunction animateDraggedToFinalPosition(shadowElIdx, callback) {\n    const shadowElRect =\n        shadowElIdx > -1\n            ? getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx], false)\n            : getBoundingRectNoTransforms(shadowElDropZone, false);\n    const newTransform = {\n        x: shadowElRect.left - parseFloat(draggedEl.style.left),\n        y: shadowElRect.top - parseFloat(draggedEl.style.top)\n    };\n    const {dropAnimationDurationMs} = dzToConfig.get(shadowElDropZone);\n    const transition = `transform ${dropAnimationDurationMs}ms ease`;\n    draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + \",\" + transition : transition;\n    draggedEl.style.transform = `translate3d(${newTransform.x}px, ${newTransform.y}px, 0)`;\n    window.setTimeout(callback, dropAnimationDurationMs);\n}\n\nfunction scheduleDZForRemovalAfterDrop(dz, destroy) {\n    scheduledForRemovalAfterDrop.push({dz, destroy});\n    window.requestAnimationFrame(() => {\n        hideElement(dz);\n        document.body.appendChild(dz);\n    });\n}\n/* cleanup */\nfunction cleanupPostDrop() {\n    // Remove the temporary elements that were kept in the DOM during the drag\n    if (draggedEl && draggedEl.remove) {\n        draggedEl.remove();\n    }\n    if (originalDragTarget && originalDragTarget.remove) {\n        originalDragTarget.remove();\n    }\n\n    draggedEl = undefined;\n    originalDragTarget = undefined;\n    draggedElData = undefined;\n    draggedElType = undefined;\n    originDropZone = undefined;\n    originIndex = undefined;\n    shadowElData = undefined;\n    shadowElDropZone = undefined;\n    dragStartMousePosition = undefined;\n    currentMousePosition = undefined;\n    isWorkingOnPreviousDrag = false;\n    finalizingPreviousDrag = false;\n    unlockOriginDzMinDimensions = undefined;\n    isDraggedOutsideOfAnyDz = false;\n    if (touchDragHoldTimer) {\n        clearTimeout(touchDragHoldTimer);\n    }\n    touchDragHoldTimer = undefined;\n    touchHoldElapsed = false;\n    if (scheduledForRemovalAfterDrop.length) {\n        printDebug(() => [\"will destroy zones that were removed during drag\", scheduledForRemovalAfterDrop]);\n        scheduledForRemovalAfterDrop.forEach(({dz, destroy}) => {\n            destroy();\n            dz.remove();\n        });\n        scheduledForRemovalAfterDrop = [];\n    }\n}\n\nexport function dndzone(node, options) {\n    let initialized = false;\n    const config = {\n        items: undefined,\n        type: undefined,\n        flipDurationMs: 0,\n        dragDisabled: false,\n        morphDisabled: false,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        transformDraggedElement: () => {},\n        centreDraggedOnCursor: false,\n        dropAnimationDisabled: false,\n        delayTouchStartMs: 0\n    };\n    printDebug(() => [`dndzone good to go options: ${toString(options)}, config: ${toString(config)}`, {node}]);\n    let elToIdx = new Map();\n\n    function addMaybeListeners() {\n        window.addEventListener(\"mousemove\", handleMouseMoveMaybeDragStart, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMoveMaybeDragStart, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleFalseAlarm, {passive: false});\n        window.addEventListener(\"touchend\", handleFalseAlarm, {passive: false});\n    }\n    function removeMaybeListeners() {\n        window.removeEventListener(\"mousemove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"touchmove\", handleMouseMoveMaybeDragStart);\n        window.removeEventListener(\"mouseup\", handleFalseAlarm);\n        window.removeEventListener(\"touchend\", handleFalseAlarm);\n        if (touchDragHoldTimer) {\n            clearTimeout(touchDragHoldTimer);\n            touchDragHoldTimer = undefined;\n            touchHoldElapsed = false;\n        }\n    }\n    function handleFalseAlarm(e) {\n        removeMaybeListeners();\n        originalDragTarget = undefined;\n        dragStartMousePosition = undefined;\n        currentMousePosition = undefined;\n\n        // dragging initiated by touch events prevents onclick from initially firing\n        if (e.type === \"touchend\") {\n            const clickEvent = new Event(\"click\", {\n                bubbles: true,\n                cancelable: true\n            });\n            // doing it this way instead of calling .click() because that doesn't work for SVG elements\n            e.target.dispatchEvent(clickEvent);\n        }\n    }\n\n    function handleMouseMoveMaybeDragStart(e) {\n        const isTouch = !!e.touches;\n        const c = isTouch ? e.touches[0] : e;\n        // If touch drag delay is configured and not elapsed yet, allow scrolling until either\n        // the delay elapses (timer will call handleDragStart) or the user moves significantly,\n        // in which case we cancel the potential drag and let the interaction be a scroll.\n        if (isTouch && config.delayTouchStartMs > 0 && !touchHoldElapsed) {\n            currentMousePosition = {x: c.clientX, y: c.clientY};\n            if (\n                Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX ||\n                Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX\n            ) {\n                // User started scrolling, cancel drag attempt.\n                if (touchDragHoldTimer) {\n                    clearTimeout(touchDragHoldTimer);\n                    touchDragHoldTimer = undefined;\n                }\n                handleFalseAlarm(e);\n            }\n            return; // Do not preventDefault so scrolling works.\n        }\n\n        // legacy / post-delay path  block scrolling and maybe start drag\n        e.preventDefault();\n\n        currentMousePosition = {x: c.clientX, y: c.clientY};\n        if (\n            Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX ||\n            Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX\n        ) {\n            removeMaybeListeners();\n            handleDragStart();\n        }\n    }\n    function handleMouseDown(e) {\n        // on safari clicking on a select element doesn't fire mouseup at the end of the click and in general this makes more sense\n        if (e.target !== e.currentTarget && (e.target.value !== undefined || e.target.isContentEditable)) {\n            printDebug(() => \"won't initiate drag on a nested input element\");\n            return;\n        }\n        // prevents responding to any button but left click which equals 0 (which is falsy)\n        if (e.button) {\n            printDebug(() => `ignoring none left click button: ${e.button}`);\n            return;\n        }\n        if (isWorkingOnPreviousDrag) {\n            printDebug(() => \"cannot start a new drag before finalizing previous one\");\n            return;\n        }\n        const isTouchStart = !!e.touches;\n        const useDelay = isTouchStart && config.delayTouchStartMs > 0;\n\n        if (!useDelay) {\n            e.preventDefault();\n        }\n        e.stopPropagation();\n\n        const c = isTouchStart ? e.touches[0] : e;\n        dragStartMousePosition = {x: c.clientX, y: c.clientY};\n        currentMousePosition = {...dragStartMousePosition};\n        originalDragTarget = e.currentTarget;\n\n        if (useDelay) {\n            touchHoldElapsed = false;\n            touchDragHoldTimer = window.setTimeout(() => {\n                // If the finger is still down and no false-alarm happened\n                if (!originalDragTarget) return;\n                touchHoldElapsed = true;\n                removeMaybeListeners();\n                handleDragStart();\n            }, config.delayTouchStartMs);\n        }\n\n        addMaybeListeners();\n    }\n\n    function handleDragStart() {\n        printDebug(() => [`drag start config: ${toString(config)}`, originalDragTarget]);\n        isWorkingOnPreviousDrag = true;\n\n        // initialising globals\n        const currentIdx = elToIdx.get(originalDragTarget);\n        originIndex = currentIdx;\n        originDropZone = originalDragTarget.parentElement;\n        /** @type {ShadowRoot | HTMLDocument | Element } */\n        const rootNode = originDropZone.closest(\"dialog\") || originDropZone.closest(\"[popover]\") || originDropZone.getRootNode();\n        const originDropZoneRoot = rootNode.body || rootNode;\n        const {items: originalItems, type, centreDraggedOnCursor} = config;\n        const items = [...originalItems];\n        draggedElData = items[currentIdx];\n        draggedElType = type;\n        shadowElData = createShadowElData(draggedElData);\n\n        // creating the draggable element\n        draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);\n        originDropZoneRoot.appendChild(draggedEl);\n        // We will keep the original dom node in the dom because touch events keep firing on it, we want to re-add it after the framework removes it\n        function keepOriginalElementInDom() {\n            if (!originalDragTarget) {\n                printDebug(() => \"originalDragTarget became undefined, aborting keepOriginalElementInDom\");\n                return;\n            }\n            if (!originalDragTarget.parentElement) {\n                originalDragTarget.setAttribute(ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE, true);\n                originDropZoneRoot.appendChild(originalDragTarget);\n                // have to watch before we hide, otherwise Svelte 5 $state gets confused\n                watchDraggedElement();\n                hideElement(originalDragTarget);\n                // to prevent the outline from disappearing\n                draggedEl.focus();\n            } else {\n                window.requestAnimationFrame(keepOriginalElementInDom);\n            }\n        }\n        window.requestAnimationFrame(keepOriginalElementInDom);\n\n        styleActiveDropZones(\n            Array.from(typeToDropZones.get(config.type)).filter(dz => dz === originDropZone || !dzToConfig.get(dz).dropFromOthersDisabled),\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n\n        // removing the original element by removing its data entry\n        items.splice(currentIdx, 1, shadowElData);\n        unlockOriginDzMinDimensions = preventShrinking(originDropZone);\n\n        dispatchConsiderEvent(originDropZone, items, {trigger: TRIGGERS.DRAG_STARTED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER});\n\n        // handing over to global handlers - starting to watch the element\n        window.addEventListener(\"mousemove\", handleMouseMove, {passive: false});\n        window.addEventListener(\"touchmove\", handleMouseMove, {passive: false, capture: false});\n        window.addEventListener(\"mouseup\", handleDrop, {passive: false});\n        window.addEventListener(\"touchend\", handleDrop, {passive: false});\n    }\n\n    function configure({\n        items = undefined,\n        flipDurationMs: dropAnimationDurationMs = 0,\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        morphDisabled = false,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        transformDraggedElement = () => {},\n        centreDraggedOnCursor = false,\n        dropAnimationDisabled = false,\n        delayTouchStart: delayTouchStartOpt = false\n    }) {\n        config.dropAnimationDurationMs = dropAnimationDurationMs;\n\n        let effectiveDelayMs = 0;\n        if (delayTouchStartOpt === true) {\n            effectiveDelayMs = DEFAULT_TOUCH_DELAY_MS;\n        } else if (typeof delayTouchStartOpt === \"number\" && isFinite(delayTouchStartOpt) && delayTouchStartOpt >= 0) {\n            effectiveDelayMs = delayTouchStartOpt;\n        }\n        config.delayTouchStartMs = effectiveDelayMs;\n\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.morphDisabled = morphDisabled;\n        config.transformDraggedElement = transformDraggedElement;\n        config.centreDraggedOnCursor = centreDraggedOnCursor;\n        config.dropAnimationDisabled = dropAnimationDisabled;\n\n        // realtime update for dropTargetStyle\n        if (\n            initialized &&\n            isWorkingOnPreviousDrag &&\n            !finalizingPreviousDrag &&\n            (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) ||\n                !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))\n        ) {\n            styleInactiveDropZones(\n                [node],\n                () => config.dropTargetStyle,\n                () => dropTargetClasses\n            );\n            styleActiveDropZones(\n                [node],\n                () => dropTargetStyle,\n                () => dropTargetClasses\n            );\n        }\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = [...dropTargetClasses];\n\n        // realtime update for dropFromOthersDisabled\n        function getConfigProp(dz, propName) {\n            return dzToConfig.get(dz) ? dzToConfig.get(dz)[propName] : config[propName];\n        }\n        if (initialized && isWorkingOnPreviousDrag && config.dropFromOthersDisabled !== dropFromOthersDisabled) {\n            if (dropFromOthersDisabled) {\n                styleInactiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            } else {\n                styleActiveDropZones(\n                    [node],\n                    dz => getConfigProp(dz, \"dropTargetStyle\"),\n                    dz => getConfigProp(dz, \"dropTargetClasses\")\n                );\n            }\n        }\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n\n        dzToConfig.set(node, config);\n        registerDropZone(node, newType);\n        const shadowElIdx = isWorkingOnPreviousDrag ? findShadowElementIdx(config.items) : -1;\n        for (let idx = 0; idx < node.children.length; idx++) {\n            const draggableEl = node.children[idx];\n            styleDraggable(draggableEl, dragDisabled);\n            if (idx === shadowElIdx) {\n                if (!morphDisabled) {\n                    morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y);\n                }\n                config.transformDraggedElement(draggedEl, draggedElData, idx);\n                decorateShadowEl(draggableEl);\n                continue;\n            }\n            draggableEl.removeEventListener(\"mousedown\", elToMouseDownListener.get(draggableEl));\n            draggableEl.removeEventListener(\"touchstart\", elToMouseDownListener.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"mousedown\", handleMouseDown);\n                draggableEl.addEventListener(\"touchstart\", handleMouseDown);\n                elToMouseDownListener.set(draggableEl, handleMouseDown);\n            }\n            // updating the idx\n            elToIdx.set(draggableEl, idx);\n\n            if (!initialized) {\n                initialized = true;\n            }\n        }\n    }\n    configure(options);\n\n    return {\n        update: newOptions => {\n            printDebug(() => `pointer dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            function destroyDz() {\n                printDebug(() => \"pointer dndzone will destroy\");\n                unregisterDropZone(node, dzToConfig.get(node).type);\n                dzToConfig.delete(node);\n            }\n            if (isWorkingOnPreviousDrag && !node.closest(`[${ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE}]`)) {\n                printDebug(() => \"pointer dndzone will be scheduled for destruction\");\n                scheduleDZForRemovalAfterDrop(node, destroyDz);\n            } else {\n                destroyDz();\n            }\n        }\n    };\n}\n","import {isOnServer} from \"../constants\";\n\nconst INSTRUCTION_IDs = {\n    DND_ZONE_ACTIVE: \"dnd-zone-active\",\n    DND_ZONE_DRAG_DISABLED: \"dnd-zone-drag-disabled\"\n};\nconst ID_TO_INSTRUCTION = {\n    [INSTRUCTION_IDs.DND_ZONE_ACTIVE]: \"Tab to one the items and press space-bar or enter to start dragging it\",\n    [INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED]: \"This is a disabled drag and drop list\"\n};\n\nconst ALERT_DIV_ID = \"dnd-action-aria-alert\";\nlet alertsDiv;\n\nfunction initAriaOnBrowser() {\n    if (alertsDiv) {\n        // it is already initialized\n        return;\n    }\n    // setting the dynamic alerts\n    alertsDiv = document.createElement(\"div\");\n    (function initAlertsDiv() {\n        alertsDiv.id = ALERT_DIV_ID;\n        // tab index -1 makes the alert be read twice on chrome for some reason\n        //alertsDiv.tabIndex = -1;\n        alertsDiv.style.position = \"fixed\";\n        alertsDiv.style.bottom = \"0\";\n        alertsDiv.style.left = \"0\";\n        alertsDiv.style.zIndex = \"-5\";\n        alertsDiv.style.opacity = \"0\";\n        alertsDiv.style.height = \"0\";\n        alertsDiv.style.width = \"0\";\n        alertsDiv.setAttribute(\"role\", \"alert\");\n    })();\n    document.body.prepend(alertsDiv);\n\n    // setting the instructions\n    Object.entries(ID_TO_INSTRUCTION).forEach(([id, txt]) => document.body.prepend(instructionToHiddenDiv(id, txt)));\n}\n\n/**\n * Initializes the static aria instructions so they can be attached to zones\n * @return {{DND_ZONE_ACTIVE: string, DND_ZONE_DRAG_DISABLED: string} | null} - the IDs for static aria instruction (to be used via aria-describedby) or null on the server\n */\nexport function initAria() {\n    if (isOnServer) return null;\n    if (document.readyState === \"complete\") {\n        initAriaOnBrowser();\n    } else {\n        window.addEventListener(\"DOMContentLoaded\", initAriaOnBrowser);\n    }\n    return {...INSTRUCTION_IDs};\n}\n\n/**\n * Removes all the artifacts (dom elements) added by this module\n */\nexport function destroyAria() {\n    if (isOnServer || !alertsDiv) return;\n    Object.keys(ID_TO_INSTRUCTION).forEach(id => document.getElementById(id)?.remove());\n    alertsDiv.remove();\n    alertsDiv = undefined;\n}\n\nfunction instructionToHiddenDiv(id, txt) {\n    const div = document.createElement(\"div\");\n    div.id = id;\n    div.innerHTML = `<p>${txt}</p>`;\n    div.style.display = \"none\";\n    div.style.position = \"fixed\";\n    div.style.zIndex = \"-5\";\n    return div;\n}\n\n/**\n * Will make the screen reader alert the provided text to the user\n * @param {string} txt\n */\nexport function alertToScreenReader(txt) {\n    if (isOnServer) return;\n    if (!alertsDiv) {\n        initAriaOnBrowser();\n    }\n    alertsDiv.innerHTML = \"\";\n    const alertText = document.createTextNode(txt);\n    alertsDiv.appendChild(alertText);\n    // this is needed for Safari\n    alertsDiv.style.display = \"none\";\n    alertsDiv.style.display = \"inline\";\n}\n","import {decrementActiveDropZoneCount, incrementActiveDropZoneCount, ITEM_ID_KEY, SOURCES, TRIGGERS} from \"./constants\";\nimport {styleActiveDropZones, styleInactiveDropZones} from \"./helpers/styler\";\nimport {dispatchConsiderEvent, dispatchFinalizeEvent} from \"./helpers/dispatcher\";\nimport {initAria, alertToScreenReader, destroyAria} from \"./helpers/aria\";\nimport {toString} from \"./helpers/util\";\nimport {printDebug} from \"./constants\";\n\nconst DEFAULT_DROP_ZONE_TYPE = \"--any--\";\nconst DEFAULT_DROP_TARGET_STYLE = {\n    outline: \"rgba(255, 255, 102, 0.7) solid 2px\"\n};\n\nlet isDragging = false;\nlet draggedItemType;\nlet focusedDz;\nlet focusedDzLabel = \"\";\nlet focusedItem;\nlet focusedItemId;\nlet focusedItemLabel = \"\";\nconst allDragTargets = new WeakSet();\nconst elToKeyDownListeners = new WeakMap();\nconst elToFocusListeners = new WeakMap();\nconst dzToHandles = new Map();\nconst dzToConfig = new Map();\nconst typeToDropZones = new Map();\n\n/* TODO (potentially)\n * what's the deal with the black border of voice-reader not following focus?\n * maybe keep focus on the last dragged item upon drop?\n */\n\nlet INSTRUCTION_IDs;\n\n/* drop-zones registration management */\nfunction registerDropZone(dropZoneEl, type) {\n    printDebug(() => \"registering drop-zone if absent\");\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"adding global keydown and click handlers\");\n        INSTRUCTION_IDs = initAria();\n        window.addEventListener(\"keydown\", globalKeyDownHandler);\n        window.addEventListener(\"click\", globalClickHandler);\n    }\n    if (!typeToDropZones.has(type)) {\n        typeToDropZones.set(type, new Set());\n    }\n    if (!typeToDropZones.get(type).has(dropZoneEl)) {\n        typeToDropZones.get(type).add(dropZoneEl);\n        incrementActiveDropZoneCount();\n    }\n}\nfunction unregisterDropZone(dropZoneEl, type) {\n    printDebug(() => \"unregistering drop-zone\");\n    if (focusedDz === dropZoneEl) {\n        handleDrop();\n    }\n    typeToDropZones.get(type).delete(dropZoneEl);\n    decrementActiveDropZoneCount();\n    if (typeToDropZones.get(type).size === 0) {\n        typeToDropZones.delete(type);\n    }\n    if (typeToDropZones.size === 0) {\n        printDebug(() => \"removing global keydown and click handlers\");\n        window.removeEventListener(\"keydown\", globalKeyDownHandler);\n        window.removeEventListener(\"click\", globalClickHandler);\n        INSTRUCTION_IDs = undefined;\n        destroyAria();\n    }\n}\n\nfunction globalKeyDownHandler(e) {\n    if (!isDragging) return;\n    switch (e.key) {\n        case \"Escape\": {\n            handleDrop();\n            break;\n        }\n    }\n}\n\nfunction globalClickHandler() {\n    if (!isDragging) return;\n    if (!allDragTargets.has(document.activeElement)) {\n        printDebug(() => \"clicked outside of any draggable\");\n        handleDrop();\n    }\n}\n\nfunction handleZoneFocus(e) {\n    printDebug(() => \"zone focus\");\n    if (!isDragging) return;\n    const newlyFocusedDz = e.currentTarget;\n    if (newlyFocusedDz === focusedDz) return;\n\n    focusedDzLabel = newlyFocusedDz.getAttribute(\"aria-label\") || \"\";\n    const {items: originItems} = dzToConfig.get(focusedDz);\n    const originItem = originItems.find(item => item[ITEM_ID_KEY] === focusedItemId);\n    const originIdx = originItems.indexOf(originItem);\n    const itemToMove = originItems.splice(originIdx, 1)[0];\n    const {items: targetItems, autoAriaDisabled} = dzToConfig.get(newlyFocusedDz);\n    if (\n        newlyFocusedDz.getBoundingClientRect().top < focusedDz.getBoundingClientRect().top ||\n        newlyFocusedDz.getBoundingClientRect().left < focusedDz.getBoundingClientRect().left\n    ) {\n        targetItems.push(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the end of the list ${focusedDzLabel}`);\n        }\n    } else {\n        targetItems.unshift(itemToMove);\n        if (!autoAriaDisabled) {\n            alertToScreenReader(`Moved item ${focusedItemLabel} to the beginning of the list ${focusedDzLabel}`);\n        }\n    }\n    const dzFrom = focusedDz;\n    dispatchFinalizeEvent(dzFrom, originItems, {trigger: TRIGGERS.DROPPED_INTO_ANOTHER, id: focusedItemId, source: SOURCES.KEYBOARD});\n    dispatchFinalizeEvent(newlyFocusedDz, targetItems, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n    focusedDz = newlyFocusedDz;\n}\n\nfunction triggerAllDzsUpdate() {\n    dzToHandles.forEach(({update}, dz) => update(dzToConfig.get(dz)));\n}\n\nfunction handleDrop(dispatchConsider = true) {\n    printDebug(() => \"drop\");\n    if (!dzToConfig.get(focusedDz).autoAriaDisabled) {\n        alertToScreenReader(`Stopped dragging item ${focusedItemLabel}`);\n    }\n    if (allDragTargets.has(document.activeElement)) {\n        document.activeElement.blur();\n    }\n    if (dispatchConsider) {\n        dispatchConsiderEvent(focusedDz, dzToConfig.get(focusedDz).items, {\n            trigger: TRIGGERS.DRAG_STOPPED,\n            id: focusedItemId,\n            source: SOURCES.KEYBOARD\n        });\n    }\n    styleInactiveDropZones(\n        typeToDropZones.get(draggedItemType),\n        dz => dzToConfig.get(dz).dropTargetStyle,\n        dz => dzToConfig.get(dz).dropTargetClasses\n    );\n    focusedItem = null;\n    focusedItemId = null;\n    focusedItemLabel = \"\";\n    draggedItemType = null;\n    focusedDz = null;\n    focusedDzLabel = \"\";\n    isDragging = false;\n    triggerAllDzsUpdate();\n}\n//////\nexport function dndzone(node, options) {\n    const config = {\n        items: undefined,\n        type: undefined,\n        dragDisabled: false,\n        zoneTabIndex: 0,\n        zoneItemTabIndex: 0,\n        dropFromOthersDisabled: false,\n        dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses: [],\n        autoAriaDisabled: false\n    };\n\n    function swap(arr, i, j) {\n        if (arr.length <= 1) return;\n        arr.splice(j, 1, arr.splice(i, 1, arr[j])[0]);\n    }\n\n    function handleKeyDown(e) {\n        printDebug(() => [\"handling key down\", e.key]);\n        switch (e.key) {\n            case \"Enter\":\n            case \" \": {\n                // we don't want to affect nested input elements or clickable elements\n                if ((e.target.disabled !== undefined || e.target.href || e.target.isContentEditable) && !allDragTargets.has(e.target)) {\n                    return;\n                }\n                e.preventDefault(); // preventing scrolling on spacebar\n                e.stopPropagation();\n                if (isDragging) {\n                    // TODO - should this trigger a drop? only here or in general (as in when hitting space or enter outside of any zone)?\n                    handleDrop();\n                } else {\n                    // drag start\n                    handleDragStart(e);\n                }\n                break;\n            }\n            case \"ArrowDown\":\n            case \"ArrowRight\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow down\", idx]);\n                if (idx < children.length - 1) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx + 2} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx + 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n            case \"ArrowUp\":\n            case \"ArrowLeft\": {\n                if (!isDragging) return;\n                e.preventDefault(); // prevent scrolling\n                e.stopPropagation();\n                const {items} = dzToConfig.get(node);\n                const children = Array.from(node.children);\n                const idx = children.indexOf(e.currentTarget);\n                printDebug(() => [\"arrow up\", idx]);\n                if (idx > 0) {\n                    if (!config.autoAriaDisabled) {\n                        alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx} in the list ${focusedDzLabel}`);\n                    }\n                    swap(items, idx, idx - 1);\n                    dispatchFinalizeEvent(node, items, {trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD});\n                }\n                break;\n            }\n        }\n    }\n    function handleDragStart(e) {\n        printDebug(() => \"drag start\");\n        setCurrentFocusedItem(e.currentTarget);\n        focusedDz = node;\n        draggedItemType = config.type;\n        isDragging = true;\n        const dropTargets = Array.from(typeToDropZones.get(config.type)).filter(dz => dz === focusedDz || !dzToConfig.get(dz).dropFromOthersDisabled);\n        styleActiveDropZones(\n            dropTargets,\n            dz => dzToConfig.get(dz).dropTargetStyle,\n            dz => dzToConfig.get(dz).dropTargetClasses\n        );\n        if (!config.autoAriaDisabled) {\n            let msg = `Started dragging item ${focusedItemLabel}. Use the arrow keys to move it within its list ${focusedDzLabel}`;\n            if (dropTargets.length > 1) {\n                msg += `, or tab to another list in order to move the item into it`;\n            }\n            alertToScreenReader(msg);\n        }\n        dispatchConsiderEvent(node, dzToConfig.get(node).items, {trigger: TRIGGERS.DRAG_STARTED, id: focusedItemId, source: SOURCES.KEYBOARD});\n        triggerAllDzsUpdate();\n    }\n\n    function handleClick(e) {\n        if (!isDragging) return;\n        if (e.currentTarget === focusedItem) return;\n        e.stopPropagation();\n        handleDrop(false);\n        handleDragStart(e);\n    }\n    function setCurrentFocusedItem(draggableEl) {\n        const {items} = dzToConfig.get(node);\n        const children = Array.from(node.children);\n        const focusedItemIdx = children.indexOf(draggableEl);\n        focusedItem = draggableEl;\n        focusedItem.tabIndex = config.zoneItemTabIndex;\n        focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];\n        focusedItemLabel = children[focusedItemIdx].getAttribute(\"aria-label\") || \"\";\n    }\n\n    function configure({\n        items = [],\n        type: newType = DEFAULT_DROP_ZONE_TYPE,\n        dragDisabled = false,\n        zoneTabIndex = 0,\n        zoneItemTabIndex = 0,\n        dropFromOthersDisabled = false,\n        dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,\n        dropTargetClasses = [],\n        autoAriaDisabled = false\n    }) {\n        config.items = [...items];\n        config.dragDisabled = dragDisabled;\n        config.dropFromOthersDisabled = dropFromOthersDisabled;\n        config.zoneTabIndex = zoneTabIndex;\n        config.zoneItemTabIndex = zoneItemTabIndex;\n        config.dropTargetStyle = dropTargetStyle;\n        config.dropTargetClasses = dropTargetClasses;\n        config.autoAriaDisabled = autoAriaDisabled;\n        if (config.type && newType !== config.type) {\n            unregisterDropZone(node, config.type);\n        }\n        config.type = newType;\n        registerDropZone(node, newType);\n        if (!autoAriaDisabled) {\n            node.setAttribute(\"aria-disabled\", dragDisabled);\n            node.setAttribute(\"role\", \"list\");\n            node.setAttribute(\"aria-describedby\", dragDisabled ? INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED : INSTRUCTION_IDs.DND_ZONE_ACTIVE);\n        }\n        dzToConfig.set(node, config);\n\n        if (isDragging) {\n            node.tabIndex =\n                node === focusedDz ||\n                focusedItem.contains(node) ||\n                config.dropFromOthersDisabled ||\n                (focusedDz && config.type !== dzToConfig.get(focusedDz).type)\n                    ? -1\n                    : 0;\n        } else {\n            node.tabIndex = config.zoneTabIndex;\n        }\n\n        node.addEventListener(\"focus\", handleZoneFocus);\n\n        for (let i = 0; i < node.children.length; i++) {\n            const draggableEl = node.children[i];\n            allDragTargets.add(draggableEl);\n            draggableEl.tabIndex = isDragging ? -1 : config.zoneItemTabIndex;\n            if (!autoAriaDisabled) {\n                draggableEl.setAttribute(\"role\", \"listitem\");\n            }\n            draggableEl.removeEventListener(\"keydown\", elToKeyDownListeners.get(draggableEl));\n            draggableEl.removeEventListener(\"click\", elToFocusListeners.get(draggableEl));\n            if (!dragDisabled) {\n                draggableEl.addEventListener(\"keydown\", handleKeyDown);\n                elToKeyDownListeners.set(draggableEl, handleKeyDown);\n                draggableEl.addEventListener(\"click\", handleClick);\n                elToFocusListeners.set(draggableEl, handleClick);\n            }\n            if (isDragging && config.items[i][ITEM_ID_KEY] === focusedItemId) {\n                printDebug(() => [\"focusing on\", {i, focusedItemId}]);\n                // if it is a nested dropzone, it was re-rendered and we need to refresh our pointer\n                focusedItem = draggableEl;\n                focusedItem.tabIndex = config.zoneItemTabIndex;\n                // without this the element loses focus if it moves backwards in the list\n                draggableEl.focus();\n            }\n        }\n    }\n    configure(options);\n\n    const handles = {\n        update: newOptions => {\n            printDebug(() => `keyboard dndzone will update newOptions: ${toString(newOptions)}`);\n            configure(newOptions);\n        },\n        destroy: () => {\n            printDebug(() => \"keyboard dndzone will destroy\");\n            unregisterDropZone(node, config.type);\n            dzToConfig.delete(node);\n            dzToHandles.delete(node);\n        }\n    };\n    dzToHandles.set(node, handles);\n    return handles;\n}\n","import {dndzone as pointerDndZone} from \"./pointerAction\";\nimport {dndzone as keyboardDndZone} from \"./keyboardAction\";\nimport {ITEM_ID_KEY, SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME} from \"./constants\";\nimport {toString} from \"./helpers/util\";\n\n/**\n * A custom action to turn any container to a dnd zone and all of its direct children to draggables\n * Supports mouse, touch and keyboard interactions.\n * Dispatches two events that the container is expected to react to by modifying its list of items,\n * which will then feed back in to this action via the update function\n *\n * @typedef {object} Options\n * @property {array} items - the list of items that was used to generate the children of the given node (the list used in the #each block\n * @property {string} [type] - the type of the dnd zone. children dragged from here can only be dropped in other zones of the same type, default to a base type\n * @property {number} [flipDurationMs] - if the list animated using flip (recommended), specifies the flip duration such that everything syncs with it without conflict, defaults to zero\n * @property {boolean} [dragDisabled]\n * @property {boolean} [morphDisabled] - whether dragged element should morph to zone dimensions\n * @property {boolean} [dropFromOthersDisabled]\n * @property {number} [zoneTabIndex] - set the tabindex of the list container when not dragging\n * @property {number} [zoneItemTabIndex] - set the tabindex of the list container items when not dragging\n * @property {object} [dropTargetStyle]\n * @property {string[]} [dropTargetClasses]\n * @property {boolean|number} [delayTouchStart] - On touch devices, wait this long before converting the gesture to a drag.\n * `true` uses the built-in default (80 ms).\n * @property {boolean} [dropAnimationDisabled] - cancels the drop animation to place\n * @property {function} [transformDraggedElement]\n * @param {HTMLElement} node - the element to enhance\n * @param {Options} options\n * @return {{update: function, destroy: function}}\n */\nexport function dndzone(node, options) {\n    if (shouldIgnoreZone(node)) {\n        return {\n            update: () => {},\n            destroy: () => {}\n        };\n    }\n    validateOptions(options);\n    const pointerZone = pointerDndZone(node, options);\n    const keyboardZone = keyboardDndZone(node, options);\n    return {\n        update: newOptions => {\n            validateOptions(newOptions);\n            pointerZone.update(newOptions);\n            keyboardZone.update(newOptions);\n        },\n        destroy: () => {\n            pointerZone.destroy();\n            keyboardZone.destroy();\n        }\n    };\n}\n\n/**\n * If the user marked something in the ancestry of our node as shadow element, we can ignore it\n * We need the user to mark it for us because svelte updates the action from deep to shallow (but renders top down)\n * @param {HTMLElement} node\n * @return {boolean}\n */\nfunction shouldIgnoreZone(node) {\n    return !!node.closest(`[${SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME}=\"true\"]`);\n}\n\nfunction validateOptions(options) {\n    /*eslint-disable*/\n    const {\n        items,\n        flipDurationMs,\n        type,\n        dragDisabled,\n        morphDisabled,\n        dropFromOthersDisabled,\n        zoneTabIndex,\n        zoneItemTabIndex,\n        dropTargetStyle,\n        dropTargetClasses,\n        transformDraggedElement,\n        autoAriaDisabled,\n        centreDraggedOnCursor,\n        delayTouchStart,\n        dropAnimationDisabled,\n        ...rest\n    } = options;\n    /*eslint-enable*/\n    if (Object.keys(rest).length > 0) {\n        console.warn(`dndzone will ignore unknown options`, rest);\n    }\n    if (!items) {\n        throw new Error(\"no 'items' key provided to dndzone\");\n    }\n    const itemWithMissingId = items.find(item => !{}.hasOwnProperty.call(item, ITEM_ID_KEY));\n    if (itemWithMissingId) {\n        throw new Error(`missing '${ITEM_ID_KEY}' property for item ${toString(itemWithMissingId)}`);\n    }\n    if (dropTargetClasses && !Array.isArray(dropTargetClasses)) {\n        throw new Error(`dropTargetClasses should be an array but instead it is a ${typeof dropTargetClasses}, ${toString(dropTargetClasses)}`);\n    }\n    if (zoneTabIndex && !isInt(zoneTabIndex)) {\n        throw new Error(`zoneTabIndex should be a number but instead it is a ${typeof zoneTabIndex}, ${toString(zoneTabIndex)}`);\n    }\n    if (zoneItemTabIndex && !isInt(zoneItemTabIndex)) {\n        throw new Error(`zoneItemTabIndex should be a number but instead it is a ${typeof zoneItemTabIndex}, ${toString(zoneItemTabIndex)}`);\n    }\n    if (delayTouchStart !== undefined && delayTouchStart !== false) {\n        const validBoolean = delayTouchStart === true;\n        const validNumber = typeof delayTouchStart === \"number\" && isFinite(delayTouchStart) && delayTouchStart >= 0;\n        if (!validBoolean && !validNumber) {\n            throw new Error(\n                `delayTouchStart should be a boolean (true/false) or a non-negative number but instead it is a ${typeof delayTouchStart}, ${toString(\n                    delayTouchStart\n                )}`\n            );\n        }\n    }\n}\n\nfunction isInt(value) {\n    return (\n        !isNaN(value) &&\n        (function (x) {\n            return (x | 0) === x;\n        })(parseFloat(value))\n    );\n}\n","export function createStore(initialValue) {\n    let _val = initialValue;\n    const subs = new Set();\n    return {\n        get: () => _val,\n        set: newVal => {\n            _val = newVal;\n            Array.from(subs).forEach(cb => cb(_val));\n        },\n        subscribe: cb => {\n            subs.add(cb);\n            cb(_val);\n        },\n        unsubscribe: cb => {\n            subs.delete(cb);\n        }\n    };\n}\n","import {SOURCES, TRIGGERS} from \"../constants\";\nimport {dndzone} from \"../action\";\nimport {createStore} from \"./simpleStore\";\n\nconst isItemsDragDisabled = createStore(true);\nconst userDragDisabled = createStore(false);\n\nfunction getAddedOptions() {\n    return {\n        dragDisabled: userDragDisabled.get() || isItemsDragDisabled.get(),\n        zoneItemTabIndex: -1\n    };\n}\n\n/**\n * This is an action that wraps around the dndzone action to make it easy to work with drag handles\n * When using this you must also use the 'dragHandle' action (see below) on an element inside each item within the zone\n * Credit for the idea and initial implementation goes to @gleuch (Greg Leuch) and @geovie (Georg Vienna)\n *\n * @param {HTMLElement} node\n * @param options - will be passed down to the dndzone\n * @return {{update: (newOptions: Object) => {}, destroy: () => {}}}\n */\nexport function dragHandleZone(node, options) {\n    // Initialise stores from initial options\n    userDragDisabled.set(options?.dragDisabled ?? false);\n\n    let currentOptions = options;\n\n    const zone = dndzone(node, {\n        ...currentOptions,\n        ...getAddedOptions()\n    });\n\n    function updateZone() {\n        zone.update({\n            ...currentOptions,\n            ...getAddedOptions()\n        });\n    }\n\n    // Subscribe to internal store so finishing a drag updates the zone\n    isItemsDragDisabled.subscribe(updateZone);\n\n    // We don't need to subscribe to userDragDisabled here because updates to\n    // it always come through the `update` lifecycle and will call `updateZone`\n    // anyway.\n\n    function consider(e) {\n        const {\n            info: {source, trigger}\n        } = e.detail;\n        // Ensure dragging is stopped on drag finish via keyboard\n        if (source === SOURCES.KEYBOARD && trigger === TRIGGERS.DRAG_STOPPED) {\n            isItemsDragDisabled.set(true);\n        }\n    }\n\n    function finalize(e) {\n        const {\n            info: {source}\n        } = e.detail;\n        // Ensure dragging is stopped on drag finish via pointer (mouse, touch)\n        if (source === SOURCES.POINTER) {\n            isItemsDragDisabled.set(true);\n        }\n    }\n\n    node.addEventListener(\"consider\", consider);\n    node.addEventListener(\"finalize\", finalize);\n\n    return {\n        update: newOptions => {\n            currentOptions = newOptions;\n            // keep store in sync with external prop\n            userDragDisabled.set(currentOptions?.dragDisabled ?? false);\n            updateZone();\n        },\n        destroy: () => {\n            node.removeEventListener(\"consider\", consider);\n            node.removeEventListener(\"finalize\", finalize);\n            isItemsDragDisabled.unsubscribe(updateZone);\n        }\n    };\n}\n\n/**\n * This should be used to mark drag handles inside items that belong to a 'dragHandleZone' (see above)\n * @param {HTMLElement} handle\n * @return {{update: *, destroy: *}}\n */\nexport function dragHandle(handle) {\n    handle.setAttribute(\"role\", \"button\");\n\n    function startDrag(e) {\n        // preventing default to prevent lag on touch devices (because of the browser checking for screen scrolling)\n        e.preventDefault();\n        isItemsDragDisabled.set(false);\n\n        // Reset the startDrag/isItemsDragDisabled if the user releases the mouse/touch without initiating a drag\n        window.addEventListener(\"mouseup\", resetStartDrag);\n        window.addEventListener(\"touchend\", resetStartDrag);\n    }\n\n    function handleKeyDown(e) {\n        if (e.key === \"Enter\" || e.key === \" \") isItemsDragDisabled.set(false);\n    }\n\n    function resetStartDrag() {\n        isItemsDragDisabled.set(true);\n        window.removeEventListener(\"mouseup\", resetStartDrag);\n        window.removeEventListener(\"touchend\", resetStartDrag);\n    }\n\n    const recomputeHandleState = () => {\n        const userDisabled = userDragDisabled.get();\n        const internalDisabled = isItemsDragDisabled.get();\n\n        if (userDisabled) {\n            handle.tabIndex = -1;\n            handle.style.cursor = \"\"; // default cursor\n        } else {\n            handle.tabIndex = internalDisabled ? 0 : -1;\n            handle.style.cursor = internalDisabled ? \"grab\" : \"grabbing\";\n        }\n    };\n\n    // Subscribe to both stores\n    userDragDisabled.subscribe(recomputeHandleState);\n    isItemsDragDisabled.subscribe(recomputeHandleState);\n\n    handle.addEventListener(\"mousedown\", startDrag);\n    handle.addEventListener(\"touchstart\", startDrag);\n    handle.addEventListener(\"keydown\", handleKeyDown);\n    return {\n        update: () => {},\n        destroy: () => {\n            handle.removeEventListener(\"mousedown\", startDrag);\n            handle.removeEventListener(\"touchstart\", startDrag);\n            handle.removeEventListener(\"keydown\", handleKeyDown);\n            userDragDisabled.unsubscribe(recomputeHandleState);\n            isItemsDragDisabled.unsubscribe(recomputeHandleState);\n        }\n    };\n}\n"],"names":["FINALIZE_EVENT_NAME","CONSIDER_EVENT_NAME","dispatchFinalizeEvent","el","items","info","dispatchConsiderEvent","DRAGGED_ENTERED_EVENT_NAME","DRAGGED_LEFT_EVENT_NAME","DRAGGED_OVER_INDEX_EVENT_NAME","DRAGGED_LEFT_DOCUMENT_EVENT_NAME","DRAGGED_LEFT_TYPES","dispatchDraggedElementEnteredContainer","containerEl","indexObj","draggedEl","dispatchDraggedElementLeftContainerForAnother","theOtherDz","dispatchDraggedElementLeftContainerForNone","dispatchDraggedElementIsOverIndex","dispatchDraggedLeftDocument","TRIGGERS","SOURCES","SHADOW_ITEM_MARKER_PROPERTY_NAME","SHADOW_ELEMENT_ATTRIBUTE_NAME","SHADOW_ELEMENT_HINT_ATTRIBUTE_NAME","SHADOW_PLACEHOLDER_ITEM_ID","DRAGGED_ELEMENT_ID","SHADOW_BACKUP_ID_PROPERTY_NAME","ITEM_ID_KEY","activeDndZoneCount","incrementActiveDropZoneCount","decrementActiveDropZoneCount","overrideItemIdKeyNameBeforeInitialisingDndZones","newKeyName","printDebug","getTrueItemId","item","isOnServer","setDebugMode","isDebug","generateMessage","logFunction","message","getBoundingRectNoTransforms","onlyVisible","ta","rect","getVisibleRectRecursive","style","tx","sx","sy","dx","dy","to","x","y","w","getAbsoluteRectNoTransforms","getAbsoluteRect","findCenter","calcDistance","pointA","pointB","isPointInsideRect","point","findCenterOfElement","isCenterOfAInsideB","elA","elB","centerOfA","rectOfB","calcDistanceBetweenCenters","centerOfB","isElementOffDocument","element","visibleRect","parent","parentRect","overflowY","overflowX","isScrollableY","isScrollableX","dzToShadowIndexToRect","resetIndexesCache","cacheShadowRect","dz","shadowElIndex","child","findWouldBeIndex","floatingAboveEl","collectionBelowEl","children","i","cachedShadowRect","minDistanceSoFar","indexOfMin","distance","toString","object","getDepth","node","_getDepth","countSoFar","areObjectsShallowEqual","objA","objB","keyA","areArraysShallowEqualSameOrder","arrA","arrB","INTERVAL_MS","TOLERANCE_PX","next","observe","dropZones","intervalMs","multiScroller","lastDropZoneFound","lastIndexFound","lastIsDraggedInADropZone","lastCentrePositionOfDragged","dropZonesFromDeepToShallow","dz1","dz2","andNow","currentCenterOfDragged","scrolled","isDraggedInADropZone","index","unobserve","SCROLL_ZONE_PX","makeScroller","scrollingInfo","resetScrolling","scrollContainer","directionObj","stepPx","calcScrollStepPx","distancePx","scrollIfNeeded","pointer","elementToScroll","distances","calcInnerDistancesBetweenPointAndSidesOfElement","isAlreadyScrolling","scrollingVertically","scrollingHorizontally","createMultiScroller","baseElementsForScrolling","getPointerPosition","scrollingContainersSet","findRelevantScrollContainers","scrollingContainersDeepToShallow","tick","mousePosition","scrollContainersUnderCursor","findScrollableParents","scrollableContainers","overflow","o","scrollingContainers","container","svelteNodeClone","cloned","values","elIsSelect","selects","select","clonedSelects","value","optionEl","elIsCanvas","canvases","clonedCanvases","canvas","clonedCanvas","FEATURE_FLAG_NAMES","featureFlagsMap","setFeatureFlag","flagName","flagValue","getFeatureFlag","TRANSITION_DURATION_SECONDS","trs","property","createDraggedElementFrom","originalElement","positionCenterOnXY","copyStylesFromTo","elTopPx","elLeftPx","center","moveDraggedElementToWasDroppedState","morphDraggedElementToBeLike","copyFromEl","currentMouseX","currentMouseY","newRect","draggedElRect","widthChange","heightChange","relativeDistanceOfMousePointerFromDraggedSides","copyToEl","computedStyle","s","styleDraggable","draggableEl","dragDisabled","hideElement","dragTarget","decorateShadowEl","shadowEl","unDecorateShadowElement","styleActiveDropZones","getStyles","getClasses","styles","c","styleInactiveDropZones","preventShrinking","originalMinHeight","originalMinWidth","DEFAULT_DROP_ZONE_TYPE","MIN_OBSERVATION_INTERVAL_MS","DISABLED_OBSERVATION_INTERVAL_MS","MIN_MOVEMENT_BEFORE_DRAG_START_PX","DEFAULT_TOUCH_DELAY_MS","DEFAULT_DROP_TARGET_STYLE","ORIGINAL_DRAGGED_ITEM_MARKER_ATTRIBUTE","originalDragTarget","draggedElData","draggedElType","originDropZone","originIndex","shadowElData","shadowElDropZone","dragStartMousePosition","currentMousePosition","isWorkingOnPreviousDrag","finalizingPreviousDrag","unlockOriginDzMinDimensions","isDraggedOutsideOfAnyDz","scheduledForRemovalAfterDrop","touchDragHoldTimer","touchHoldElapsed","typeToDropZones","dzToConfig","elToMouseDownListener","registerDropZone","dropZoneEl","type","unregisterDropZone","watchDraggedElement","handleDraggedEntered","handleDraggedLeft","handleDraggedIsOverIndex","handleDrop","setIntervalMs","observationIntervalMs","unWatchDraggedElement","findShadowElementIdx","createShadowElData","dropFromOthersDisabled","newOriginZoneItems","isProximityBased","shadowElIdx","originalItems","origShadowDz","originZoneItems","handleMouseMove","finalizeWithinZone","domShadowEl","cleanupPostDrop","animateDraggedToFinalPosition","callback","shadowElRect","newTransform","dropAnimationDurationMs","transition","scheduleDZForRemovalAfterDrop","destroy","dndzone","options","initialized","config","elToIdx","addMaybeListeners","handleMouseMoveMaybeDragStart","handleFalseAlarm","removeMaybeListeners","e","clickEvent","isTouch","handleDragStart","handleMouseDown","isTouchStart","useDelay","currentIdx","rootNode","originDropZoneRoot","centreDraggedOnCursor","keepOriginalElementInDom","configure","newType","morphDisabled","dropTargetStyle","dropTargetClasses","transformDraggedElement","dropAnimationDisabled","delayTouchStartOpt","effectiveDelayMs","getConfigProp","propName","idx","newOptions","destroyDz","INSTRUCTION_IDs","ID_TO_INSTRUCTION","ALERT_DIV_ID","alertsDiv","initAriaOnBrowser","id","txt","instructionToHiddenDiv","initAria","destroyAria","div","alertToScreenReader","alertText","isDragging","draggedItemType","focusedDz","focusedDzLabel","focusedItem","focusedItemId","focusedItemLabel","allDragTargets","elToKeyDownListeners","elToFocusListeners","dzToHandles","globalKeyDownHandler","globalClickHandler","handleZoneFocus","newlyFocusedDz","originItems","originItem","originIdx","itemToMove","targetItems","autoAriaDisabled","triggerAllDzsUpdate","update","dispatchConsider","swap","arr","j","handleKeyDown","setCurrentFocusedItem","dropTargets","msg","handleClick","focusedItemIdx","zoneTabIndex","zoneItemTabIndex","handles","shouldIgnoreZone","validateOptions","pointerZone","pointerDndZone","keyboardZone","keyboardDndZone","flipDurationMs","delayTouchStart","rest","itemWithMissingId","isInt","validBoolean","validNumber","createStore","initialValue","_val","subs","newVal","cb","isItemsDragDisabled","userDragDisabled","getAddedOptions","dragHandleZone","currentOptions","zone","updateZone","consider","source","trigger","finalize","dragHandle","handle","startDrag","resetStartDrag","recomputeHandleState","userDisabled","internalDisabled"],"mappings":"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"}